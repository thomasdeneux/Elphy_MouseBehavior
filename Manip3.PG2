{$EDIT Variables}
////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Variables other than parameters //////////////////
////////////////////////////////////////////////////////////////////////////////

    
const
  Sound_Sampling_Frequency= 192000;    // Hz
  //Lick_Sampling_Frequency = 1000;      // Hz
var
  plot, maskPlot: TXYplot;
  bar, dumBar: Tbar; // dumBar and dumStim will be displayed anyway: they force the duration of the VisualStimulation to a certain length
  Stim, dumStim: TonOff;
  Stim2: array [0..1] of TonOff; 
  anim: Ttrajectory; // used to create animation, e.g. the looming circle
  maskBar: array [1..2] of Tbar;
  xCenter, yCenter: real; // center (not 0 if masking)
  gratings: array [1..2] of TLGrating;
  shiftgrat: array [1..2] of TphaseTranslation; // move the grating
  bitmap: TVSbitmap;
  bstream: TVSstream;
  circle: Tdisk;
  circle2: array [0..1] of Tdisk;
  CRecord: Tvector;
  TRecord: Tvector;
  WaitVect: Tvector;
  LickRecord: Tvector;
  vfilt: Tvector;
  NIanalog, Ni: TNIinterface;
  ParamWin: Tdialog;
  OkParamWin: boolean; // tells whether ParamWin has been initialized already
  FileList: Tmemo;
  SoundList,ImageList: Tmemo;
  FileNameHandle: integer;
  Sounds: array [1..10000] of TVector;
  LoadedSounds: array [1..10000] of TVector;
  MaxSoundDuration: real;
  detector: Tdetector;
  Vdetect: Tvector;
  level:TDBRecord; 
  RandomizationVector: TVector;
  
  vect,kernel: TVector;
  Go:integer;
  res: integer;
  gh,Vbase:real;
  time0:integer;
  cnt, ICond: integer;
  
  ValveOpen: boolean;
  rewardTotal: real;
  activeReward: boolean;
  CountLicks: integer;
  
  status: TstatusBar;     // use display('some text') or status.text[k]:='some text' to display some text in the status bar

  i,j,k: integer;         // it is usefull to have some 'available' integer variables without needing to declare them in the functions
  a,b: real;              // same for reals
  str,str1,str2: string;  // same for strings
  
  memRND: real; // memory for RandomN function
  
  lcr:TLCR; // DLP


{$EDIT Tools}
////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Small tools //////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

procedure display(text:string);
begin
  status.text[1]:=text;
end;

function min(a,b:real):real;
begin
  if a<b then min:=a else min:=b;
end;

function max(a,b:real):real;
begin
  if a>b then max:=a else max:=b;
end;

procedure ErrorDlg(text:string);
begin
    InitDialogBox;
    DBsetCaption('ERROR');
    DBSetText(text);
    ShowDialogBox;
end;

// Normal distribtution random number (mean 0, std 1)
function RandomN:real;
var
  p,r,theta: real;
begin
  if memRND=0 then
  begin
    // Gaussian Distribution: 1/sqrt(2*pi) exp(-x^2/2) dx
    // 2D Gaussian Distribution: 1/(2*pi) exp(-(x^2+y^2)/2) dx dy
    //     = 1/(2*pi) exp(-r^2/2) r dr dtheta
    // p(>r) = int_r-inf int_o-2pi 1/(2*pi) exp(-r^2/2) r dr dtheta
    //       = [-exp(-r^2/2)]_r^inf
    //       = exp(-r^2/2) 
    p := Random;
    r := sqrt(-2*Ln(p));
    theta := 2*pi*Random;
    RandomN := r*cos(theta);
    memRND := r*sin(theta);
  end
  else
  begin
    RandomN:=memRND;
    memRND:=0;
  end;
end;

{$EDIT Parameters}
////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Parameters ///////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// The way to handle parameters that take different values for different
// conditions is to store in a table (called 'StimTable') their name and values; 
// this table is used to overwrite the values of these parameters each time the 
// condition changes.
//
// Experiment protocols can be defined in a .csv file.
// For each parameter the .csv file can contain 1 or NStim value, depending on 
// whether this parameter changes or not for different conditions.
// 
// It is also possible to use the menus to define the protocol, though they offer
// less flexibility. The menus have additional parameters such as 'VProtocolType'
// or 'alpha1' which are used to generate the stim table.
//
// Additionally, there are a few local parameters which are specific to each machine 
// (e.g. name of the acquisition card) and are saved in a file named
// Manip3_LocalParameters.param.
  

var
  // Experiment parameters
  // (general)
  TriggerType: word;
  ContinuousRec, Behavior, Auditory, Visual: boolean; 
  MaxTrialNumber: integer;
  NStim,NStimPerEp,NRepPerBlock: integer; 
  // (timing)
  StimDelay,VisualStimDuration: integer;
  LickCountingDelay,RewardDelay,RandomDelay,PunitionDelay,RefractoryTime,RandomRefractoryTime: integer;
  TrialInterval: integer;
  // (behavior)
  DetectionType,RewardCriterion: word;
  TaskType: word; // 1 for S+, 2 for S-
  LickThresholdTop, LickThresholdBottom: real;
  LickNumber,NFreeTrials: integer; 
  rewardVolume, rewardSlope: real;  
  // (visual stim)
  VStimType: word; // no menu
  BackgroundLuminance: integer;
  KeepGratingOn,SquareWaveGrating: boolean;
  MaskType: word; 
  VAlpha, VOri, VOri2: real; // no menu
  Vx, Vy: real;
  Vx2, Vy2: real;
  VSize, VSize2, VSpeed, VLum: real;
  VLum2: real;
  VLED: integer; 
  ImageListFile: string;  
  ImageIdx: integer;
  // (audio stim)
  SStimType: word; // no menu
  SFreq, SFreq2: real; // no menu
  SLevelDB, SLevelDB2, SAlpha, SDuration, SDelay: real;
  SoundListFile: string;
  SoundIdx: integer;
  // (acquisition)
  EphysPeriod, EphysGain: real;
  
  // "StimGen" parameters
  // (general)
  ProtocolType: word;
  // (visual stim)
  VProtocolType: word;  
  alpha1, alpha2: real;
  beta1, beta2: real;
  size1, size2: real;
  led1, led2: integer;
  // (audio Stim)
  SProtocolType: word;
  f1, f2: real;
     
  // Handling of parameters
  DoMenu: boolean;     // Are we using the menus?
  StimTable: TDBtable; // Values of parameters that change in different conditions
  ParList: TDBrecord;  // All the parameters and their types
  spar: TDBrecord;     // An intermediary for when reading .csv file
  ProtocolList,DetectionList,TriggerList,RewardCriterionList: Tmemo;       // Various lists
  VisualProtocols,AuditoryProtocols,VisualStimuli,AuditoryStimuli: Tmemo;
  MaskList: Tmemo;
  AllListMemo: Tmemo; // summarizes the correspondence between list items and numbers
    
  // Local parameters
  Dev, PFI: string;
  rewardConversion: real;
  localpar : TDBrecord; // local parameters 
  
  // Parameter files
const
  //DefaultMenuParameterFile = 'C:\Users\THomas\Desktop\default.param'; 
  //LocalParameterFile = 'C:\Users\THomas\Desktop\Manip3_LocalParameters.param'; 
  DefaultMenuParameterFile = 'Y:\Behavior\Elphy\parameters\default.param';
  LocalParameterFile = 'D:\Elphy Programs\Manip3_LocalParameters.param';
  ListMemoFile = 'Y:\Behavior\Elphy\parameters\LISTS_MEMO.csv';

var
  ParameterFile,ParameterDir,ParameterFileBase: string;
  ParameterChanged: boolean;
  PPar2: TMemo;  // Parameters are first copied into a memo, which is then saved to a file
  MPar2: TDBrecord; // Menu parameters are first copied into a TDBrecord, which is then saved to a file 
    

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Local parameters /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


procedure InitLocalParameters;
begin
  localpar.create;
  // load or create local parameter file
  if FileExists(LocalParameterFile) then
  begin
    localpar.LoadObject(LocalParameterFile);
    Dev := localpar.dev;
    if localpar.fieldExists('rewardConversion') then rewardConversion := localpar.rewardConversion;
  end
  else
  begin
    Dev:=Dev;
    InitDialogBox;
    DBgetString('NI Board',Dev,4);
    ShowDialogBox;
    localpar.dev := Dev;
    localpar.ParameterFile:=DefaultMenuParameterFile;
    localpar.rewardConversion:=0; // will be set later by user
    localpar.SaveAsObject(LocalParameterFile);
  end;
  // read or create more recent field(s)
  if localpar.fieldExists('PFI') then 
    PFI := localpar.PFI
  else
  begin
    InitDialogBox;
    PFI := 'PFI1';
    DBgetString('Sound trigger line',PFI,4);
    ShowDialogBox;
    localpar.PFI := PFI;
    localpar.SaveAsObject(LocalParameterFile);
  end;
end;

procedure SaveLocalParameters;
begin
  if ParameterChanged then
    localpar.ParameterFile:=DefaultMenuParameterFile
  else
    localpar.ParameterFile:=ParameterFile;
  localpar.rewardConversion:=rewardConversion;
  localpar.SaveAsObject(LocalParameterFile);
end;

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Default parameters ///////////////////////////////
////////////////////////////////////////////////////////////////////////////////

procedure SetDefaultParameters;
begin
  // Global parameters
  // (general)
  TriggerType:=1;
  ContinuousRec:=FALSE;
  Behavior:=TRUE;
  Auditory:=TRUE;
  Visual:=TRUE;
  MaxTrialNumber:=1000;
  NStim:=2;
  NStimPerEp:=1;
  NRepPerBlock:=4;
  // (timing)
  StimDelay:=1000;
  VisualStimDuration:=1000;
  LickCountingDelay:=0;
  RewardDelay:=1000;
  RandomDelay:=0;
  PunitionDelay:=0;
  RefractoryTime:=0;
  RandomRefractoryTime:=0;
  TrialInterval:=0;
  // (behavior)
  DetectionType:=2;
  RewardCriterion:=1;
  TaskType:=1;
  LickThresholdTop:=4000;
  LickThresholdBottom:=2500;
  LickNumber:=1;
  NFreeTrials:=0;
  rewardVolume:=8;
  rewardSlope:=0;
  // (visual stim)  
  BackgroundLuminance:=25;
  KeepGratingOn:=FALSE;
  SquareWaveGrating:=FALSE;
  MaskType:=0;
  // Stim parameters
  // (visual stim)
  VStimType:=1;
  VAlpha:=0;
  VOri:=180;
  VOri2:=0;
  Vx:=0;
  Vy:=0;
  Vx2:=0;
  Vy2:=0;
  VSize:=7;
  VSize2:=7;
  VSpeed:=400;
  VLum:=100;
  VLum2:=100;
  VLED:=200;
  ImageListFile:='';
  ImageIdx:=0;
  // (audio stim)
  SStimType:=1;
  SFreq:=8000;
  SFreq2:=16000;
  SLevelDB:=70;
  SLevelDB2:=70;
  SAlpha:=0;
  SDuration:=200;
  SDelay:=0;
  SoundListFile:='';
  SoundIdx:=0;
  // StimGen parameters
  // (general)
  ProtocolType:=1;
  // (visual stim)
  VProtocolType:=1;
  alpha1:=180;
  alpha2:=0;
  beta1:=0;
  beta2:=0;
  size1:=10;
  size2:=10;
  led1:=200;
  led2:=200; 
  ImageListFile:='';
  // (audio stim)
  SProtocolType:=1;
  f1:=8000;
  f2:=16000;
  SoundListFile:='';
  // (acquisition)
  EphysPeriod:=1; //in ms, ie 1 kHz (if Ephys actually acquired, set to 0.05ms ie 20 kHz)
  EphysGain:=1000; //one possible setting for extracelullar headstage
  
end;

////////////////////////////////////////////////////////////////////////////////
//////////////////// Copy parameters (a very repetitive section) ///////////////
////////////////////////////////////////////////////////////////////////////////

// Parameter types
procedure DefineParList;
begin
  parlist.create;
  // (general)
  parlist.TriggerType := db_integer;
  parlist.ContinuousRec := db_boolean;
  parlist.Behavior := db_boolean;
  parlist.Auditory := db_boolean;
  parlist.Visual := db_boolean;
  parlist.MaxTrialNumber := db_integer;
  parlist.NStim := db_integer; 
  parlist.NStimPerEp := db_integer; 
  parlist.NRepPerBlock := db_integer; 
  // (timing)
  parlist.StimDelay := db_integer;
  parlist.VisualStimDuration := db_integer;
  parlist.LickCountingDelay := db_integer;
  parlist.RewardDelay := db_integer;
  parlist.RandomDelay := db_integer;
  parlist.PunitionDelay := db_integer;
  parlist.RefractoryTime := db_integer;
  parlist.RandomRefractoryTime := db_integer;
  parlist.TrialInterval := db_integer;
  // (behavior)
  parlist.DetectionType := db_integer;
  parlist.RewardCriterion := db_integer;
  parlist.TaskType := db_integer;
  parlist.LickThresholdTop := db_real;
  parlist.LickThresholdBottom := db_real;
  parlist.LickNumber := db_integer; 
  parlist.NFreeTrials := db_integer; 
  parlist.rewardVolume := db_real;  
  parlist.rewardSlope := db_real;  
  // (visual stim)
  parlist.VStimType := db_integer;
  parlist.BackgroundLuminance := db_integer;
  parlist.KeepGratingOn := db_boolean;
  parlist.SquareWaveGrating := db_boolean;
  parlist.MaskType := db_integer;
  parlist.VAlpha := db_real;
  parlist.VOri := db_real;
  parlist.VOri2 := db_real;
  parlist.Vx := db_real; 
  parlist.Vy := db_real; 
  parlist.Vx2 := db_real; 
  parlist.Vy2 := db_real; 
  parlist.VSize := db_real; 
  parlist.VSize2 := db_real; 
  parlist.VSpeed := db_real; 
  parlist.VLum := db_real; 
  parlist.VLum2 := db_real;
  parlist.VLED := db_integer;
  parlist.ImageListFile := db_string;
  parlist.ImageIdx := db_integer;
  // (audio stim)
  parlist.SStimType := db_integer;
  parlist.SFreq := db_real;
  parlist.SFreq2 := db_real;
  parlist.SLevelDB := db_real;
  parlist.SLevelDB2 := db_real;
  parlist.SAlpha := db_real;
  parlist.SDuration := db_real;
  parlist.SDelay := db_real;
  parlist.SoundListFile := db_string;
  parlist.SoundIdx := db_integer;
  // (acquisition)
  parlist.EphysPeriod := db_real;
  parlist.EphysGain := db_real;
end;

// Init the stim table
procedure InitStimTable;
begin
  with StimTable do
  begin
    // Create
    create;
    // Display properties
    DefaultColWidth:=90;
    FirstRowVisible:=true;
    FirstColVisible:=true;
    ButtonColumn:=true;
    CanModify:=true;
    RowSelect:=true;
    ColWidths[1]:=100;    
    FixedColor:=cl_yellow;
    MarkColor:=cl_green;
  end;  
end;

// Save parameters in a TMemo object (which itself can be saved both in a .csv file and in the .DAT file)
procedure FullPar2Memo;
begin
  with ppar2 do
  begin
    // Init memo
    ppar2.create;
    
    // Single values
    // (general)
    Addline('TriggerType'+';'+Istr(TriggerType));
    Addline('ContinuousRec'+';'+Bstr(ContinuousRec));
    Addline('Behavior'+';'+Bstr(Behavior));
    Addline('Auditory'+';'+Bstr(Auditory));
    Addline('Visual'+';'+Bstr(Visual));
    Addline('MaxTrialNumber'+';'+Istr(MaxTrialNumber));
    Addline('NStim'+';'+Istr(NStim)); 
    Addline('NStimPerEp'+';'+Istr(NStimPerEp)); 
    Addline('NRepPerBlock'+';'+Istr(NRepPerBlock)); 
    // (timing)
    Addline('StimDelay'+';'+Istr(StimDelay));
    Addline('VisualStimDuration'+';'+Istr(VisualStimDuration));
    Addline('LickCountingDelay'+';'+Istr(LickCountingDelay));
    Addline('RewardDelay'+';'+Istr(RewardDelay));
    Addline('RandomDelay'+';'+Istr(RandomDelay));
    Addline('PunitionDelay'+';'+Istr(PunitionDelay));
    Addline('RefractoryTime'+';'+Istr(RefractoryTime));
    Addline('RandomRefractoryTime'+';'+Istr(RandomRefractoryTime));
    Addline('TrialInterval'+';'+Istr(TrialInterval));
    // (behavior)
    Addline('DetectionType'+';'+Istr(DetectionType));
    Addline('RewardCriterion'+';'+Istr(RewardCriterion));
    Addline('TaskType'+';'+Istr(TaskType));
    Addline('LickThresholdTop'+';'+Rstr(LickThresholdTop));
    Addline('LickThresholdBottom'+';'+Rstr(LickThresholdBottom));
    Addline('LickNumber'+';'+Istr(LickNumber)); 
    Addline('NFreeTrials'+';'+Istr(NFreeTrials)); 
    Addline('rewardVolume'+';'+Rstr(rewardVolume));  
    Addline('rewardSlope'+';'+Rstr(rewardSlope));  
    // (visual stim)
    Addline('VStimType'+';'+Istr(VStimType));
    Addline('BackgroundLuminance'+';'+Istr(BackgroundLuminance));
    Addline('KeepGratingOn'+';'+Bstr(KeepGratingOn));
    Addline('SquareWaveGrating'+';'+Bstr(SquareWaveGrating));
    Addline('MaskType'+';'+Istr(MaskType));
    Addline('VAlpha'+';'+Rstr(VAlpha));
    Addline('VOri'+';'+Rstr(VOri));
    Addline('VOri2'+';'+Rstr(VOri2));
    Addline('Vx'+';'+Rstr(Vx));
    Addline('Vy'+';'+Rstr(Vy));
    Addline('Vx2'+';'+Rstr(Vx2));
    Addline('Vy2'+';'+Rstr(Vy2));
    Addline('VSize'+';'+Rstr(VSize)); 
    Addline('VSize2'+';'+Rstr(VSize2)); 
    Addline('VSpeed'+';'+Rstr(VSpeed)); 
    Addline('VLum'+';'+Rstr(VLum)); 
    Addline('VLum2'+';'+Rstr(VLum2));
    Addline('VLED'+';'+Istr(VLED));
    AddLine('ImageListFile'+';'+ImageListFile);  
    AddLine('ImageIdx'+';'+Istr(ImageIdx));  
    // (audio stim)
    Addline('SStimType'+';'+Istr(SStimType));
    Addline('SFreq'+';'+Rstr(SFreq));
    Addline('SFreq2'+';'+Rstr(SFreq2));
    Addline('SLevelDB'+';'+Rstr(SLevelDB));
    Addline('SLevelDB2'+';'+Rstr(SLevelDB2));
    Addline('SAlpha'+';'+Rstr(SAlpha));
    Addline('SDuration'+';'+Rstr(SDuration));
    Addline('SDelay'+';'+Rstr(SDelay));
    AddLine('SoundListFile'+';'+SoundListFile);
    AddLine('SoundIdx'+';'+Istr(SoundIdx));  
    // (acquisition)
    Addline('EphysPeriod'+';'+Rstr(EphysPeriod));
    Addline('EphysGain'+';'+Rstr(EphysGain));
    
    // Multiple values in StimTable
    for j:=1 to StimTable.ColCount do
    begin
      str:=StimTable.Names(j);
      for i:=1 to StimTable.RowCount do
      begin
        case StimTable.VType(j) of
          DB_Boolean: str1:=Bstr(StimTable[i].Value[j]);
          DB_Integer: str1:=Istr(StimTable[i].Value[j]);
          DB_Real:    str1:=Rstr(StimTable[i].Value[j]);
          DB_String:  str1:=StimTable[i].Value[j];
        end;
        str:=str+';'+str1;
      end;
      AddLine(str);
    end;
  end;
end;

// Assign a value to a TDBrecord or table entry
procedure AssignRecord(var spar:TDBrecord;fieldname:string;valuestr:string);
var 
  vtype: integer;
begin
  if (not ParList.FieldExists(fieldname)) then ErrorDlg('Invalid Parameter: '+fieldname);
  vtype := ParList.ImplicitValue[fieldname];
  case vtype of
    db_boolean: spar.ImplicitValue[fieldname]:=((valuestr='TRUE') OR (valuestr='true'));
    db_integer: spar.ImplicitValue[fieldname]:=ValInt(valuestr);
    db_real:    spar.ImplicitValue[fieldname]:=ValReal(valuestr);
    db_string:  spar.ImplicitValue[fieldname]:=valuestr;
  end;
end;
procedure AssignStimTable(i:integer;fieldname:string;value:string);
var 
  vtype: integer;
begin
  vtype := ParList.ImplicitValue[fieldname];
  case vtype of
    db_boolean: StimTable[i].ImplicitValue[fieldname]:=((value='TRUE') OR (value='true'));
    db_integer: StimTable[i].ImplicitValue[fieldname]:=ValInt(value);
    db_real:    StimTable[i].ImplicitValue[fieldname]:=ValReal(value);
    db_string:  StimTable[i].ImplicitValue[fieldname]:=value;
  end;
end;
  
// Assign parameter values from a TDBrecord
procedure Record2Par(var spar:TDBrecord);
begin
  // (general)
  if spar.fieldExists('TriggerType') then TriggerType:=spar.TriggerType;
  if spar.fieldExists('ContinuousRec') then ContinuousRec:=spar.ContinuousRec;
  if spar.fieldExists('Behavior') then Behavior:=spar.Behavior;
  if spar.fieldExists('Auditory') then Auditory:=spar.Auditory;
  if spar.fieldExists('Visual') then Visual:=spar.Visual;
  if spar.fieldExists('MaxTrialNumber') then MaxTrialNumber:=spar.MaxTrialNumber;
  if spar.fieldExists('NStim') then NStim:=spar.NStim; 
  if spar.fieldExists('NStimPerEp') then NStimPerEp:=spar.NStimPerEp; 
  if spar.fieldExists('NRepPerBlock') then NRepPerBlock:=spar.NRepPerBlock; 
  // (timing)
  if spar.fieldExists('StimDelay') then StimDelay:=spar.StimDelay;
  if spar.fieldExists('VisualStimDuration') then VisualStimDuration:=spar.VisualStimDuration;
  if spar.fieldExists('LickCountingDelay') then LickCountingDelay:=spar.LickCountingDelay;
  if spar.fieldExists('RewardDelay') then RewardDelay:=spar.RewardDelay;
  if spar.fieldExists('RandomDelay') then RandomDelay:=spar.RandomDelay;
  if spar.fieldExists('PunitionDelay') then PunitionDelay:=spar.PunitionDelay;
  if spar.fieldExists('RefractoryTime') then RefractoryTime:=spar.RefractoryTime;
  if spar.fieldExists('RandomRefractoryTime') then RandomRefractoryTime:=spar.RandomRefractoryTime;
  if spar.fieldExists('TrialInterval') then TrialInterval:=spar.TrialInterval;
  // (behavior)
  if spar.fieldExists('DetectionType') then DetectionType:=spar.DetectionType;
  if spar.fieldExists('RewardCriterion') then RewardCriterion:=spar.RewardCriterion;
  if spar.fieldExists('TaskType') then TaskType:=spar.TaskType;
  if spar.fieldExists('LickThresholdTop') then LickThresholdTop:=spar.LickThresholdTop;
  if spar.fieldExists('LickThresholdBottom') then LickThresholdBottom:=spar.LickThresholdBottom;
  if spar.fieldExists('LickNumber') then LickNumber:=spar.LickNumber; 
  if spar.fieldExists('NFreeTrials') then NFreeTrials:=spar.NFreeTrials; 
  if spar.fieldExists('rewardVolume') then rewardVolume:=spar.rewardVolume;  
  if spar.fieldExists('rewardSlope') then rewardSlope:=spar.rewardSlope;  
  // (visual stim)
  if spar.fieldExists('VStimType') then VStimType:=spar.VStimType;
  if spar.fieldExists('BackgroundLuminance') then BackgroundLuminance:=spar.BackgroundLuminance;
  if spar.fieldExists('KeepGratingOn') then KeepGratingOn:=spar.KeepGratingOn;
  if spar.fieldExists('SquareWaveGrating') then SquareWaveGrating:=spar.SquareWaveGrating;
  if spar.fieldExists('MaskType') then MaskType:=spar.MaskType;
  if spar.fieldExists('VAlpha') then VAlpha:=spar.VAlpha;
  if spar.fieldExists('VOri') then VOri:=spar.VOri;
  if spar.fieldExists('VOri2') then VOri2:=spar.VOri2;
  if spar.fieldExists('Vx') then Vx:=spar.Vx; 
  if spar.fieldExists('Vy') then Vy:=spar.Vy; 
  if spar.fieldExists('Vx2') then Vx2:=spar.Vx2; 
  if spar.fieldExists('Vy2') then Vy2:=spar.Vy2; 
  if spar.fieldExists('VSize') then VSize:=spar.VSize; 
  if spar.fieldExists('VSize2') then VSize2:=spar.VSize2; 
  if spar.fieldExists('VSpeed') then VSpeed:=spar.VSpeed; 
  if spar.fieldExists('VLum') then VLum:=spar.VLum; 
  if spar.fieldExists('VLum2') then VLum2:=spar.VLum2;
  if spar.fieldExists('VLED') then VLED:=spar.VLED;
  if spar.fieldExists('ImageListFile') then ImageListFile:=spar.ImageListFile; 
  if spar.fieldExists('ImageIdx') then ImageIdx:=spar.ImageIdx;
  // (audio stim)
  if spar.fieldExists('SStimType') then SStimType:=spar.SStimType;
  if spar.fieldExists('SFreq') then SFreq:=spar.SFreq else if spar.fieldExists('Sfreq') then SFreq:=spar.Sfreq;
  if spar.fieldExists('SFreq2') then SFreq2:=spar.SFreq2 else if spar.fieldExists('Sfreq2') then SFreq2:=spar.Sfreq2;
  if spar.fieldExists('SLevelDB') then SLevelDB:=spar.SLevelDB;
  if spar.fieldExists('SLevelDB2') then SLevelDB2:=spar.SLevelDB2;
  if spar.fieldExists('SAlpha') then SAlpha:=spar.SAlpha;
  if spar.fieldExists('SDuration') then SDuration:=spar.SDuration;
  if spar.fieldExists('SDelay') then SDelay:=spar.SDelay;
  if spar.fieldExists('SoundListFile') then SoundListFile:=spar.SoundListFile; 
  if spar.fieldExists('SoundIdx') then SoundIdx:=spar.SoundIdx;
  // (acquisition)
  if spar.fieldExists('EphysPeriod') then EphysPeriod:=spar.EphysPeriod;
  if spar.fieldExists('EphysGain') then EphysGain:=spar.EphysGain;
end;

// Load parameters from TMemo object
procedure Memo2FullPar;
var
  oneline:string;
  p:integer; // position in string
  multcond:boolean;
  fieldname:string;
  firstvalue:string;
  valuetype:integer;        
begin
  // Init stim table and intermediary storage for unique-value parameters
  InitStimTable;
  spar.create;
  
  // Scan the text line per line to feed StimTable and spar    
  for j:=1 to ppar2.count do
  begin
    oneline:=ppar2.lines[j];
    i:=-1; // condition number <-> column in table
    p:=0;  // position reading in table
    while p<=length(oneline) do
    begin
      // read characters until a delimiter is reached
      inc(p);
      str:='';
      while (p<=length(oneline)) AND (oneline[p]<>';') do
      begin
        str:=str+oneline[p];
        inc(p);
      end;
      // action with completed string   
      inc(i);   
      case i of
        0: begin 
             if str[1]='#' then break; // this line is a comment
             fieldname:=str;
           end;
        1: firstvalue:=str;
        2: begin
            if (str='') then
            begin
              // no more than one value
              AssignRecord(spar,fieldname,firstvalue);
              break;
            end else
            begin
              // more than one value: assign the 1st and 2d values
              AssignRecord(StimTable[1],fieldname,firstvalue);
              AssignRecord(StimTable[2],fieldname,str);
            end;
           end;
        else AssignRecord(StimTable[i],fieldname,str); // assign the ith value
      end; 
    end;  
    if i=1 then AssignRecord(spar,fieldname,firstvalue);   
  end;
  
  // Define unique-value parameters from spar
  SetDefaultParameters;
  Record2Par(spar);  
end; 

// The function below is not a mere copy but interprets the 'stimgen' parameters,
// therefore it is more appropriate to have its code later below.
procedure MenuPar2FullPar;forward; 

procedure MenuPar2TDBrecord;
begin
  mpar2.create;
  // Global parameters
  // (general)
  mpar2.TriggerType:=TriggerType;
  mpar2.Behavior:=Behavior;
  mpar2.Auditory:=Auditory;
  mpar2.Visual:=Visual;
  mpar2.MaxTrialNumber:=MaxTrialNumber;
  mpar2.NStim:=NStim;
  mpar2.NStimPerEp:=NStimPerEp;
  mpar2.NRepPerBlock:=NRepPerBlock;
  // (timing)
  mpar2.StimDelay:=StimDelay;
  mpar2.VisualStimDuration:=VisualStimDuration;
  mpar2.LickCountingDelay:=LickCountingDelay;
  mpar2.RewardDelay:=RewardDelay;
  mpar2.RandomDelay:=RandomDelay;
  mpar2.PunitionDelay:=PunitionDelay;
  mpar2.RefractoryTime:=RefractoryTime;
  mpar2.RandomRefractoryTime:=RandomRefractoryTime;
  mpar2.TrialInterval:=TrialInterval;  
  // (behavior)
  mpar2.DetectionType:=DetectionType;
  mpar2.RewardCriterion:=RewardCriterion;
  mpar2.LickThresholdTop:=LickThresholdTop;
  mpar2.LickThresholdBottom:=LickThresholdBottom;
  mpar2.LickNumber:=LickNumber;
  mpar2.NFreeTrials:=NFreeTrials;
  mpar2.rewardVolume:=rewardVolume;
  mpar2.rewardSlope:=rewardSlope;
  // (visual stim)  
  mpar2.BackgroundLuminance:=BackgroundLuminance;
  mpar2.KeepGratingOn:=KeepGratingOn;
  mpar2.SquareWaveGrating:=SquareWaveGrating;
  mpar2.MaskType:=MaskType;
  // Stim parameters
  // (visual stim)
  mpar2.VSize:=VSize;
  mpar2.VSpeed:=VSpeed;
  mpar2.VLum:=VLum;
  mpar2.VLED:=VLED;
  // (audio stim)
  mpar2.SDuration:=SDuration;
  mpar2.SDelay:=SDelay;
  mpar2.SFreq:=SFreq;
  mpar2.SLevelDB:=SLevelDB;
  // StimGen parameters
  // (general)
  mpar2.ProtocolType:=ProtocolType;
  // (visual stim)
  mpar2.VProtocolType:=VProtocolType;
  mpar2.alpha1:=alpha1; 
  mpar2.alpha2:=alpha2;
  mpar2.beta1:=beta1; 
  mpar2.beta2:=beta2;
  mpar2.size1:=size1; 
  mpar2.size2:=size2;
  mpar2.led1:=led1; 
  mpar2.led2:=led2;
  mpar2.ImageListFile:=ImageListFile;
  // (audio stim)
  mpar2.SProtocolType:=SProtocolType;
  mpar2.f1:=f1; 
  mpar2.f2:=f2;
  mpar2.SoundListFile:=SoundListFile;
  // (acquisition)
  mpar2.EphysPeriod:=EphysPeriod;
  mpar2.EphysGain:=EphysGain;
end;

procedure TDBrecord2MenuPar;
var
  doMask: boolean;
begin
  // Global parameters
  // (general)
  if mpar2.fieldExists('TriggerType') then TriggerType:=mpar2.TriggerType else if mpar2.DetectionType=3 then TriggerType:=2 else TriggerType:=1;
  if mpar2.fieldExists('Behavior') then Behavior:=mpar2.Behavior else Behavior:=TRUE;
  Auditory:=mpar2.Auditory;
  Visual:=mpar2.Visual;
  MaxTrialNumber:=mpar2.MaxTrialNumber;
  if mpar2.fieldExists('NStim') then NStim:=mpar2.NStim else NStim:=mpar2.NIntermediateStim+2;
  if mpar2.fieldExists('NStimPerEp') then NStimPerEp:=mpar2.NStimPerEp else NStimPerEp:=1;
  if mpar2.fieldExists('NRepPerBlock') then NRepPerBlock:=mpar2.NRepPerBlock else NRepPerBlock:=4;
  // (timing)
  StimDelay:=mpar2.StimDelay;
  VisualStimDuration:=mpar2.VisualStimDuration;
  if mpar2.fieldExists('LickCountingDelay') then LickCountingDelay:=Floor(mpar2.LickCountingDelay) else LickCountingDelay:=0;
  RewardDelay:=mpar2.RewardDelay;
  if mpar2.fieldExists('RandomDelay') then RandomDelay:=Floor(mpar2.RandomDelay) else RandomDelay:=0;
  if mpar2.fieldExists('PunitionDelay') then PunitionDelay:=Floor(mpar2.PunitionDelay) else PunitionDelay:=0;
  if mpar2.fieldExists('RefractoryTime') then RefractoryTime:=Floor(mpar2.RefractoryTime) else RefractoryTime:=0;
  if mpar2.fieldExists('RandomRefractoryTime') then RandomRefractoryTime:=Floor(mpar2.RandomRefractoryTime) else RandomRefractoryTime:=0;
  TrialInterval:=mpar2.TrialInterval;  
  // (behavior)
  DetectionType:=mpar2.DetectionType;
  if mpar2.fieldExists('RewardCriterion') then RewardCriterion:=mpar2.RewardCriterion else RewardCriterion:=1;
  LickThresholdTop:=mpar2.LickThresholdTop;
  LickThresholdBottom:=mpar2.LickThresholdBottom;
  LickNumber:=mpar2.LickNumber;
  NFreeTrials:=mpar2.NFreeTrials;
  if mpar2.fieldExists('rewardVolume') then rewardVolume:=mpar2.rewardVolume else if rewardConversion>0 then rewardVolume:=mpar2.ValveOpenTime/rewardConversion else rewardVolume:=0;
  if mpar2.fieldExists('rewardSlope') then rewardSlope:=mpar2.rewardSlope else rewardSlope:=0;
  // (visual stim)  
  if mpar2.fieldExists('BackgroundLuminance') then BackgroundLuminance:=mpar2.BackgroundLuminance else BackgroundLuminance:=25;
  if mpar2.fieldExists('KeepGratingOn') then KeepGratingOn:=mpar2.KeepGratingOn else KeepGratingOn:=FALSE;
  if mpar2.fieldExists('SquareWaveGrating') then SquareWaveGrating:=mpar2.SquareWaveGrating else SquareWaveGrating:=FALSE;
  if mpar2.fieldExists('MaskType') then MaskType:=mpar2.MaskType else if mpar2.fieldExists('DoMask') then begin doMask:=mpar2.DoMask; MaskType:=Ord(doMask); end else MaskType:=0;
  // Stim parameters
  // (visual stim)
  VSize:=mpar2.VSize;
  if mpar2.fieldExists('VSpeed') then VSpeed:=mpar2.VSpeed else VSpeed:=0;
  VLum:=mpar2.VLum;
  if mpar2.fieldExists('VLED') then VLED:=mpar2.VLED else VLED:=200;
  // (audio stim)
  if mpar2.fieldExists('SDuration') then SDuration:=mpar2.SDuration else SDuration:=100;
  if mpar2.fieldExists('SDelay') then SDelay:=mpar2.SDelay else SDelay:=0;
  if mpar2.fieldExists('SFreq') then SFreq:=mpar2.SFreq else SFreq:=8000;
  if mpar2.fieldExists('SLevelDB') then SLevelDB:=mpar2.SLevelDB else if mpar2.SLevel<>0 then SLevelDB:=100+Ln(mpar2.SLevel)/ln(10)*20 else SLevelDB:=70;
  
  // StimGen parameters
  // (general)
  ProtocolType:=mpar2.ProtocolType;
  // (visual stim)
  VProtocolType:=mpar2.VProtocolType;
  alpha1:=mpar2.alpha1; 
  alpha2:=mpar2.alpha2;
  if mpar2.fieldExists('beta1') then beta1:=mpar2.beta1 else beta1:=0;
  if mpar2.fieldExists('beta2') then beta2:=mpar2.beta2 else beta2:=0;
  if mpar2.fieldExists('size1') then size1:=mpar2.size1 else size1:=10;
  if mpar2.fieldExists('size2') then size2:=mpar2.size2 else size2:=10;
  if mpar2.fieldExists('led1') then led1:=mpar2.led1 else led1:=200;
  if mpar2.fieldExists('led2') then led2:=mpar2.led2 else led2:=200;
  if mpar2.fieldExists('ImageListFile') then ImageListFile:=mpar2.ImageListFile else ImageListFile:='';
  // (audio stim)
  SProtocolType:=mpar2.SProtocolType;
  f1:=mpar2.f1; 
  f2:=mpar2.f2;
  if mpar2.fieldExists('SoundListFile') then SoundListFile:=mpar2.SoundListFile else SoundListFile:='';
  // (acquisition)
  if mpar2.fieldExists('EphysPeriod') then EphysPeriod:=mpar2.EphysPeriod else EphysPeriod:=1;
  if mpar2.fieldExists('EphysGain') then EphysGain:=mpar2.EphysGain else EphysGain:=1000;
end;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Load/save parameters /////////////////////////////
////////////////////////////////////////////////////////////////////////////////


// Save parameters
procedure SaveDefaultMenuParameters;
begin
  MenuPar2TDBrecord; // copy menu parameters from mpar to mpar2
  mpar2.SaveAsObject(DefaultMenuParameterFile);
  SaveLocalParameters; // possible change in localpar.ParameterFile if ParameterChanged became true
end;


procedure SaveParameters(FileName:string);
var
  ext: string;
begin
  // Select file
  if DoMenu then ext:='.param' else ext:='.csv';
  if length(FileName)=0 then
  begin
    FileName:=ParameterDir+'*'+ext;
    SaveFileDialog(FileName,ext);
  end;
  
  // Memorize file name (folder, base and full file)
  SplitFileName(FileName,ParameterDir,ParameterFileBase,str2);
  ParameterFile:=ParameterDir+ParameterFileBase+ext;
  ParameterChanged:=false;
  SaveLocalParameters;
  
  // Save menu parameters into .param file if we are in Menu mode
  if DoMenu then 
  begin
    MenuPar2TDBrecord; // copy menu parameters from mpar to mpar2
    mpar2.SaveAsObject(ParameterFile);
    MenuPar2FullPar;
  end;

  // Save full parameters in any case
  FullPar2Memo; // copy experiment parameters and stim table to ppar2
  ppar2.SaveToFile(ParameterDir+'\'+ParameterFileBase+'.csv');
  
  // Add the extension to the base file name
  ParameterFileBase:=ParameterFileBase+ext;
end;


procedure SaveParametersDatafile; // Save parameters into data file
begin
  if DoMenu then 
  begin
    MenuPar2TDBrecord; // copy menu parameters from mpar to mpar2
    Datafile0.AppendObject(mpar2);
  end;
  FullPar2Memo;
  Datafile0.AppendObject(ppar2);
  Datafile0.AppendObject(ImageList);
  Datafile0.AppendObject(SoundList);
end;

// Load Parameters
procedure DesignMenu;forward; // Need to declare this function that will be defined later

procedure LoadParameters(FileName:string);
var
  valid:boolean;
  ext:string;
begin
  // Select file
  //if length(FileName)=0 then
  //begin
    FileName:=ParameterDir+'*.*';
    ChooseFile(FileName,'Choose parameter file');
  //end;

  // Memorize file name (folder, base and full file)
  SplitFileName(FileName,str1,str2,ext);
  if ext='.param' then
    DoMenu:=true
  else if ext='.csv' then
    DoMenu:=false
  else
    begin ErrorDlg('Parameter file must be with extension .param or .csv'); break; end;
  ParameterDir:=str1;
  ParameterFile:=FileName;
  ParameterFileBase:=str2+ext;
  SaveLocalParameters;
  ParameterChanged:=false;

  // Load the parameters
  if DoMenu then
  begin
    mpar2.create;
    mpar2.LoadObject(FileName);
    TDBrecord2MenuPar; // copy menu parameters from mpar2 to mpar
    MenuPar2FullPar;   // Generate the full parameters (single parameters + stim table)
  end
  else
  begin
    ppar2.create;
    ppar2.LoadFromFile(FileName);
    Memo2FullPar; // copy parameters from ppar2 to single parameters + stim table
  end;
  
  // Redisplay the menu (because many controls do not appear if we are not in Menu mode)
  DesignMenu; 
end;



////////////////////////////////////////////////////////////////////////////////
////////////// Advanced parameter functions and other settings /////////////////
////////////////////////////////////////////////////////////////////////////////

// Init all lists that appear in the menus
procedure DefineParameterLists;
begin
  AllListMemo.create;

  with ProtocolList do
  begin
    create;
    addLine('Bimodal ambiguity');
    addLine('Double unimodal ambiguities');
    addLine('Pre-training with S+');
    addLine('Pre-training with both stimuli');
    addLine('Touch test');
  end;
  AllListMemo.addLine('ProtocolList');
  for i:=1 to ProtocolList.count do AllListMemo.addLine(Istr(i)+';'+ProtocolList.lines[i]);

  with TriggerList do
  begin
    create;
    addLine('none');
    addLine('fork');
    addLine('microscope');
    addLine('no lick');
  end;
  AllListMemo.addLine('TriggerList');
  for i:=1 to TriggerList.count do AllListMemo.addLine(Istr(i)+';'+TriggerList.lines[i]);

  with RewardCriterionList do
  begin
    create;
    addLine('Lick Count');
    addLine('Immediate on lick');
  end;
  AllListMemo.addLine('RewardCriterionList');
  for i:=1 to RewardCriterionList.count do AllListMemo.addLine(Istr(i)+';'+RewardCriterionList.lines[i]);

  with DetectionList do
  begin
    create;
    addLine('Touch: Downward crossing');
    addLine('Lick, head fixed: Electric contact');
    addLine('Lick, freely moving: IR fork');
    addLine('Lick, head fixed: Active electric contact');

  end;
  AllListMemo.addLine('DetectionList');
  for i:=1 to DetectionList.count do AllListMemo.addLine(Istr(i)+';'+DetectionList.lines[i]);

  with VisualStimuli do
  begin
    create;
    addLine('Star-Square');
    addLine('Grating');
    addLine('Two gratings');
    addLine('Image');
    addLine('Circle');
    addLine('Looming circle');
    addLine('none');
    addLine('Square');
  end;  
  AllListMemo.addLine('VisualStimuli');
  for i:=1 to VisualStimuli.count do AllListMemo.addLine(Istr(i)+';'+VisualStimuli.lines[i]);

  with VisualProtocols do
  begin
    create;
    addLine('Star-Square');
    addLine('Gratings & Amplitude morphing');
    addLine('Loaded images');
    addLine('Luminance Circles');
    addLine('Gratings & Orientation morphing');
    addLine('Looming circle');
    addLine('none');
    addLine('Squares at 2 positions');
    addLine('Disks at 2 positions');
    addLine('Disks at 2 positions and common disk');
  end;  
  AllListMemo.addLine('VisualProtocols');
  for i:=1 to VisualProtocols.count do AllListMemo.addLine(Istr(i)+';'+VisualProtocols.lines[i]);

  with MaskList do
  begin
    create;
    addLine('none');
    addLine('4:3');
    addLine('24:13');
  end;  
  AllListMemo.addLine('MaskList');
  for i:=1 to MaskList.count do AllListMemo.addLine(Istr(i)+';'+MaskList.lines[i]);
  
  with AuditoryStimuli do
  begin
    create;
    addLine('Tone');
    addLine('Two tones');
    addLine('Frequency ramp');
    addLine('Two frequency ramps');
    addLine('File');
    addLine('Two files');
    addLine('Amplitude ramp');
    addLine('none');
  end;
  AllListMemo.addLine('AuditoryStimuli');
  for i:=1 to AuditoryStimuli.count do AllListMemo.addLine(Istr(i)+';'+AuditoryStimuli.lines[i]);

  with AuditoryProtocols do
  begin
    create;
    addLine('Two tones & frequency morphing');
    addLine('Two tones & amplitude morphing');
    addLine('Frequency ramp & frequency morphing');
    addLine('Frequency ramp & amplitude morphing');
    addLine('Loaded files');
    addLine('Two loaded files  & amplitude morphing');
    addLine('Amplitude ramp');
    addLine('none');
  end;
  AllListMemo.addLine('AuditoryProtocols');
  for i:=1 to AuditoryProtocols.count do AllListMemo.addLine(Istr(i)+';'+AuditoryProtocols.lines[i]);

  AllListMemo.SaveToFile(ListMemoFile);
end;

// Settings = experiment parameters + local parameters + other variables
procedure InitSettings;
begin
  // init some variables which are not parameters
  rewardTotal:=0;
  DoMenu:=TRUE;
  SoundList.create; // must be created even if it will not be used -> can be saved then
  ImageList.create; // same

  // local parameters
  InitLocalParameters;

  // experiment parameters
  DefineParList;
  DefineParameterLists;
  if localpar.fieldExists('ParameterFile') and FileExists(localpar.ParameterFile) then
    LoadParameters(localpar.ParameterFile)
  else if FileExists(DefaultMenuParameterFile) then
    LoadParameters(DefaultMenuParameterFile)
  {else
    SetDefaultParametersAndSave};
end;


// Re-init reward count dialog
procedure InitRewardCount;
var
  doZero:boolean;
  button:integer;
begin
  if rewardTotal>0 then
  begin
      if QueryBox('Reset reward count?') then
      begin
        rewardTotal:=0;
        ParamWin.update;
      end;
  end;
end;

// Start the experiment only if the parameters obey the following rules
function CheckCurrentSettings:boolean;
var
  test: boolean;
begin
  CheckCurrentSettings:=TRUE;
  if NStimPerEp>1 then
  begin
    if (not Auditory) and (not Visual) then
    begin
      ErrorDlg('Neither Visual nor Auditory is selected!');
      CheckCurrentSettings:=FALSE;
    end;
    if Behavior then
    begin
      ErrorDlg('Several Stim per Episode is valid only for passive experiments.');
      CheckCurrentSettings:=FALSE;
    end;
    if Visual then
    begin
      for i:=1 to NStim do
      begin
        status.text[4]:='missing check for nstimperep>1 / visual';
      end;
    end;
    if TrialInterval<max(1000,VisualStimDuration+RewardDelay+100) then
    begin
      ErrorDlg('Several Stim per Episode: Min Trial Interval must be greater than VisualStimDuration+RewardDelay+100ms and at least 1 second.');
      CheckCurrentSettings:=FALSE;
    end;
    if (MaxTrialNumber mod NStimPerEp)<>0 then
    begin
      ErrorDlg('Number of Stim per Episode must divide total number of trials.');
      CheckCurrentSettings:=FALSE;
    end;
  end;

end;

// Generate the stim table from menu parameters
procedure MenuPar2FullPar; 
var
  ObjValueV, ObjValueS: real; // value between 0 (<-> object A) and 1 (<-> object B)
begin
  // General parameters
  case ProtocolType of
    1..2: NStim:=NStim;
    3: begin NStim:=1; TaskType:=1; end;
    4: NStim:=2;
    5: NStim:=0; 
  end;
  ContinuousRec:=(ProtocolType=5);
  if OkParamWin then ParamWin.update;
  if ContinuousRec then break; // there are no stim parameters in continuous mode

  // Stim table
  InitStimTable;
  with StimTable do
  begin
    for i:=1 to NStim do
    begin
      // Condition index for sound (inversion for protocol 'Double unimodal ambiguities')
      if ProtocolType=2 then 
        if i<=NStim/2 then j:=Floor(NStim/2)+1-i else j:=NStim+1-(i-Floor(NStim/2)) 
      else
        j:=i;
      // Object values
      if NStim=1 then
        begin ObjValueV:=0; ObjValueS:=0; end
      else
        begin ObjValueV:=(i-1)/(NStim-1); ObjValueS:=(j-1)/(NStim-1); end;
      // Visual stim
      case VProtocolType of
        // Star-Square
        1: begin VStimType:=1; stimtable[i].VAlpha:=alpha1*(1-ObjValueV)+alpha2*ObjValueV; end;
        // Gratings & Amplitude morphing
        2: begin VStimType:=3; VOri:=alpha1; VOri2:=alpha2; stimtable[i].VAlpha:=ObjValueV; end;
        // Loaded images
        3: begin VStimType:=4; stimtable[i].ImageIdx:=i; end;
        // Luminance Circles
        4: begin VStimType:=5; stimtable[i].VLum:=alpha1*(1-ObjValueV)+alpha2*ObjValueV; end;
        // Gratings & Orientation morphing
        5: begin VStimType:=2; stimtable[i].VOri:=alpha1*(1-ObjValueV)+alpha2*ObjValueV; end;
        // Looming Circle
        6: begin VStimType:=6; stimtable[i].VSize:=alpha1*(1-ObjValueV)+alpha2*ObjValueV; stimtable[i].VSize2:=alpha2*(1-ObjValueV)+alpha1*ObjValueV; end;
        //6: begin VStimType:=6; stimtable[i].VSize:=Exp(Ln(alpha1)*(1-ObjValueV)+Ln(alpha2)*ObjValueV); stimtable[i].VSize2:=Exp(Ln(alpha2)*(1-ObjValueV)+Ln(alpha1)*ObjValueV); end;
        // none
        7: VStimType:=7;
        // Rectangle at 2 positions
        8: begin VStimType:=8; stimtable[i].Vx:=alpha1*(1-ObjValueV)+alpha2*ObjValueV; stimtable[i].Vy:=beta1*(1-ObjValueV)+beta2*ObjValueV; end; 
        // Circles at 2 positions
        9: begin VStimType:=5; stimtable[i].Vx:=alpha1*(1-ObjValueV)+alpha2*ObjValueV; stimtable[i].Vy:=beta1*(1-ObjValueV)+beta2*ObjValueV; stimtable[i].VSize:=size1*(1-ObjValueV)+size2*ObjValueV;stimtable[i].VLED:=floor(led1*(1-ObjValueV)+led2*ObjValueV);end; 
        // Circles at 2 positions with common circle
        10: begin VStimType:=9; stimtable[i].Vx:=alpha1*(1-ObjValueV)+alpha2*ObjValueV; stimtable[i].Vy:=beta1*(1-ObjValueV)+beta2*ObjValueV; stimtable[i].VSize:=size1*(1-ObjValueV)+size2*ObjValueV;stimtable[i].VLED:=floor(led1*(1-ObjValueV)+led2*ObjValueV);end; 
      end;
      // Audio stim
      SStimType:=SProtocolType;
      case SProtocolType of
        // Two tones & frequency morphing (logarithmic scale!)
        1: begin stimtable[i].SFreq:=Exp(Ln(f1)*(1-ObjValueS)+Ln(f2)*ObjValueS); end;
        // Two tones & amplitude morphing
        2: begin SFreq:=f1; SFreq2:=f2; stimtable[i].SAlpha:=ObjValueS; end;
        // Ramp & frequency morphing (logarithmic scale!)
        3: begin stimtable[i].SFreq:=Exp(Ln(f1)*(1-ObjValueS)+Ln(f2)*ObjValueS); stimtable[i].SFreq2:=Exp(Ln(f2)*(1-ObjValueS)+Ln(f1)*ObjValueS); stimtable[i].SAlpha:=ObjValueS; end;
        // Ramp & amplitude morphing
        4: begin stimtable[i].SFreq:=f1; stimtable[i].SFreq2:=f2; stimtable[i].SAlpha:=ObjValueS; end;
        // Loaded sounds
        5: stimtable[i].SoundIdx:=j;
        // Two loaded files & amplitude morphing
        6: stimtable[i].SAlpha:=ObjValueS;  
        // Amplitude ramp (logarithmic scale!)
        7: begin stimtable[i].SLevelDB:=f1*(1-ObjValueS)+f2*ObjValueS; stimtable[i].SLevelDB2:=f2*(1-ObjValueS)+f1*ObjValueS; end;
        // 8 = none
      end;
      // Reward parameters
      if ProtocolType<>3 then stimtable[i].TaskType := 1+Ord(i>NStim/2);
    end;
  end;
end; 


{$EDIT GUI}
////////////////////////////////////////////////////////////////////////////////
///////////////////////////// GUI / Dialog boxes ///////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Menu window
procedure ParamWinCallback(N:integer);forward;

procedure DesignMenu;
begin
  with ParamWin do
  begin
    // Init and split
    create;
    dividePanel('1',3,FALSE);
    if DoMenu then
      splitPanel('1.2','General|Timing|Behavior|Visual Stim|Audio Stim|Acquisition');

    // Files menu
    selectPanel('1.1');
    FileNameHandle:=setText(ParameterFileBase);
    if not Domenu then
      getCommandA('Reload',Go,101);
    getCommandA('Load Parameters...',Go,102);
    if DoMenu then
    begin
      getCommandA('Save Parameters',Go,103);
      getCommandA('Save Parameters as...', Go, 104);
    end;
    
    getRealA('Reward conversion (ms/ul)',rewardConversion,4,1,105);
    getReal('Total Reward (ul)',rewardTotal,4,1);
    setText(''); // add a separation line
  
    if DoMenu then
    begin
      // General parameters menu
      selectPanel('1.2.1');
      getstringList1A('Protocol Type',ProtocolList,ProtocolType,501);
      getstringList1('Trigger',TriggerList,TriggerType);
      getInteger('# Stimuli',NStim,5);
      getInteger('# Stim per Episode',NStimPerEp,5);
      getInteger('# Repetition per randomized block',NRepPerBlock,5);
      getInteger('Max. trial number',MaxTrialNumber,5);
      setText(''); // add a separation line
      getBoolean('Behavior', Behavior);
      getBoolean('Visual', Visual);
      getBoolean('Auditory', Auditory);
    
      // Timing
      selectPanel('1.2.2');
      getInteger('Refractory time (ms)',RefractoryTime,5);
      getInteger('+ random refractory time (ms)',RandomRefractoryTime,5);
      getInteger('Stimulation delay (ms)',StimDelay,5);
      getInteger('Visual stimulation duration (ms)',VisualStimDuration,5);
      getInteger('Lick counting delay (ms)',LickCountingDelay,5);
      getInteger('Reward delay (ms)',RewardDelay,5);
      getInteger('Punition delay (ms)',PunitionDelay,5);
      getInteger('Min trial interval (ms)',TrialInterval,5);
      getInteger('+ random delay (ms)',RandomDelay,5);
    
      // Behavior
      selectPanel('1.2.3');
      getstringList1('Detection Type',DetectionList,DetectionType);
      getstringList1('Reward  Criterion',RewardCriterionList,RewardCriterion);
      getInteger('Minimal lick number',LickNumber,5);
      getReal('Sensor top threshold (mV)',LickThresholdTop,5,1);
      getReal('Sensor bottom threshold (mV)',LickThresholdBottom,5,1);
      getReal('Reward volume (ul)',rewardVolume,5,1);
      getReal('Extra reward per extra lick (ul)',rewardSlope,5,1);
      getInteger('# free training trials',NFreeTrials,5);
    
      // Visual parameters
      selectPanel('1.2.4');
      getstringList1('Stimulus protocol',VisualProtocols,VProtocolType);
      getInteger('Background Luminance',BackgroundLuminance,5);
      getBoolean('Keep grating on',KeepGratingOn);
      getBoolean('Square wave grating',SquareWaveGrating);
      getstringList1('Bottom-left mask',MaskList,MaskType);
      getReal('S+ parameter',alpha1,5,3);
      getReal('S+ parameter 2',beta1,5,3);
      getReal('S+ size',size1,5,3);
      getInteger('S+ LED',led1,3);
      getReal('S- parameter',alpha2,5,3);
      getReal('S- parameter 2',beta2,5,3);
      getReal('S- size',size2,5,3);
      getInteger('S- LED',led2,3);
      getReal('Object Size',VSize,5,1);
      getReal('Object Luminance',VLum,5,1);
      getReal('Speed',VSpeed,5,1);
      getString('Image list file',ImageListFile,30);
      getCommandA('Choose images', Go,301);
      getCommandA('Test visual stim', Go,302);
      getCommandA('Calibration image for DLP', Go,303);
      getCommandA('LEDs off', Go,304);
    
      // Auditory parameters
      selectPanel('1.2.5');
      getstringList1A('Stimulus protocol',AuditoryProtocols,SProtocolType,502);
      getReal('S+ parameter',f1,5,3);
      getReal('S- parameter',f2,5,3);
      getReal('Duration',SDuration,5,1);
      getReal('Delay',SDelay,5,1);
      getReal('Frequency',SFreq,5,1);
      getReal('Amplitude (dB)',SLevelDB,5,1);
      getString('Sound list file',SoundListFile,30);
      getCommandA('Load sounds', Go,401);
      getCommandA('Test sounds', Go,402);
      
      // Acquisition parameters
      selectPanel('1.2.6');
      getReal('Ephys (v3) period per channel (ms)',EphysPeriod,5,3);
      getReal('Ephys total amplification',EphysGain,5,3);
      
    end else
    begin
      // Very simplified menu with no protocol parameter
      selectPanel('1.2');
      //getstringList1('Trigger',TriggerList,TriggerType);
      getInteger('Max. trial number',MaxTrialNumber,5);
      setText(''); // add a separation line
      getCommandA('Test visual stim', Go,302);
      getCommandA('Test sounds', Go,402);      
    end;

    // Main commands
    selectPanel('1.3');
    setText(''); // add a separation line
    getCommandA('Start', Go,201);
    getCommandA('Test stim', Go,206);
    getCommandA('Give 1 reward', Go,203);
    getCommandA('Give [lick number] rewards', Go,204);
    getBooleanA('Valve Open', ValveOpen,205);
  
    // Assign callbacks
    OnEvent:=ParamWinCallback;
  end;

  // Display the parameters window
  MGpage['Behavior'].adddialog(5,ParamWin);
end;

// Build the GUI
procedure  DesignPage;
begin
   deleteallpages('Behavior');
   Go:=0;

  // Create the Windows
  if PageIndex('Behavior') = 0  then  Addpage('Behavior');
  with MGpage['Behavior'] do
  begin
   color := rgb(250,250,250);
   destroyAllwindows;
   DefineWindow(0,0,pagewidth-400,floor(pageheight/4));
   DefineWindow(0,floor(pageheight/4),pagewidth-400,floor(pageheight*2/4));
   DefineWindow(0,floor(pageheight*2/4),pagewidth-400,floor(pageheight*3/4));
   DefineWindow(0,floor(pageheight*3/4),pagewidth-400,pageheight);
   DefineWindow(pagewidth-400,0,pagewidth,pageheight);
  end;
end;

procedure FillPage;
begin
  with MGpage['Behavior'] do
  begin
   addobject(1,v[1]);   vfilt.create;   addobject(1,vfilt);
   addobject(1,v[2]);
   addobject(2,v[3]); // ephys channel
   addobject(3,LickRecord);
   addobject(4,CRecord);
   PageFont := true;
   scalecolor := rgb(10,10,10);
  end;

  // Create the parameter window
  DesignMenu;
end;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// Callback ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

procedure RunTheExp;forward;
procedure ChooseImages;forward;
procedure TestVisualStim(doAudio:boolean);forward;
procedure ChooseSounds;forward;
procedure TestSounds;forward;
procedure OpenValve(volume:real);forward;
procedure OpenCloseValve;forward;
procedure CalibDLPImage;forward;
procedure LEDsOff;forward;

// Update parameters display, including the name of the parameter file
procedure ParamWinUpdate;
begin
  str:=ParameterFileBase;
  if ParameterChanged then str:=str+'*';
  ParamWin.ModifyText(FileNameHandle,str);
  ParamWin.update;
end;


// Callback procedure for the ParamWin dialog (parameters + start)
procedure ParamWinCallback(N:integer);
var
  i: integer;
  ParChg: boolean;
begin
  // Update parameter values
  ParamWin.updatevar;
  
  Randomize;
  
  // Perform action
  case N of
    // File actions
    101: LoadParameters(ParameterFile);
    102: LoadParameters('');
    103: SaveParameters(ParameterFile);
    104: SaveParameters('');
    105: SaveLocalParameters; // rewardConversion has changed
    // General parameters
    201: RunTheExp;
    203: OpenValve(rewardVolume);
    204: for i:=1 to LickNumber do begin delay(1000+Floor(Random*8000)); display(Istr(i)); OpenValve(rewardVolume); end;
    // Random*8000: every 5s on avg; Random*24000: every 13s on avg; Random*48000: every 25s on avg
    205: OpenCloseValve;
    206: TestVisualStim(TRUE);
    // Visual parameters
    301: begin ChooseImages; ParChg:=true; end;
    302: TestVisualStim(FALSE);
    303: CalibDLPImage;
    304: LEDsOff;
    // Sound parameters
    401: begin ChooseSounds; ParChg:=true; end;
    402: TestSounds;
    // Otherwise, some parameter has probably been changed
    else ParChg:=true;
  end;
  
  // Mark that some parameter has changed
  if ParChg then
  begin 
    ParameterChanged:=true;
    if DoMenu then 
    begin
      MenuPar2FullPar;
      // Warning message: not twisting loaded sounds
      if (ProtocolType=2) AND (SProtocolType=5) AND ((N=501) OR (N=502)) then 
        MessageBox('Warning: loaded sounds will be twisted for "double unimodal ambiguities" protocol.');
    end;
  end;
  
  // Most actions require a display update (especially for the parameter file name)
  ParamWinUpdate;
end;

{$EDIT VisualStim}
////////////////////////////////////////////////////////////////////////////////
////////////////////////// Visual stimulation //////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Mask
procedure MakeMask;
var
  Nb: integer;
  W,H: real;
begin
  // Mask mode: center in the bottom-left part of the screen
  W:=stimScreen.width;
  H:=stimScreen.height;
  yCenter:=H*(-0.5+0.3); 
  case MaskType of
    2: xCenter:=W*(-0.5+0.3);       // 4:3
    3: xCenter:=W*(-0.5+0.3*18/13); // 24:13
  end;
  // create the mask (2 rectangles)
  for i:=1 to 2 do
  with maskBar[i] do
  begin
    create;
    if i=1 then
    begin
      x:=0;
      dx:=W;
      y:=H/2+yCenter; // the calculation to get this is weird...
      dy:=-2*yCenter;
    end else
    begin
      x:=W/2+xCenter;
      dx:=-2*xCenter;
      y:=0;
      dy:=H;
    end;
    Lum:=0;
    OnScreen:=TRUE;
    ZDistance:=-10;
  end;   
end;

// dumBar: an object which is not visible, but forces VisualStim
// to be of the appropriate length
procedure MakeDumBar(EpisodeDuration:integer);
begin
  with dumBar do
  begin
    create;
    x:=-StimScreen.Width/2+1;
    y:=StimScreen.Height/2-1;
    dx:=1;
    dy:=1;
    Lum:=BackgroundLuminance;
  end;
  with dumStim do
  begin
    create;
    DtON := EpisodeDuration/1000; // seconds
    setSyncPulse(0);
    setVisualObject(dumBar);
  end;
end;


// Design the square or star shape.
// Square: alpha = 0 ; Star : 0 < alpha < 1
// ObjValue: object A = 0, object B = 1, intermediate: 0 < ObjValue < 1
procedure MakeStarContour;
var
  xc,yc,DD:real;
  Nb:integer;
begin
  Nb:=8; DD:=VSize;

  // create the contour (TXYplot object)
  with plot do
  begin
    create;
    AddPolyline;
    with polylines[1] do
    begin
      for k:=0 to Nb do
        addPoint(DD*(1-(k mod 2)*VAlpha)*(1+(k mod 2)*(-1+1/sqrt(2))) *cos(2*pi/Nb*k),
                 DD*(1-(k mod 2)*VAlpha)*(1+(k mod 2)*(-1+1/sqrt(2)))*sin(2*pi/Nb*k));
    end;
  end;

  // create the bar (Tbar object) and assign the contour to it
  with bar do
  begin
    create;
    x:=xCenter;
    y:=yCenter;
    dx:=VSize*2;
    dy:=VSize*2;
    Lum:=VLum;
    setContour(plot);
    UseContour:=TRUE;
  end;

  // create stim (TOnOff object)and assign the bar to it
  with stim do
  begin
    create;
    StartTime:=StimDelay/1000; // secondes
    DtON:= VisualStimDuration/1000;
    DtOff:= 0;
    setSyncPulse(0);
    setVisualObject(bar);
  end;
end;

// Image display
procedure MakeBitmap;
begin
  // create image (TVSbitmap object)
  with bitmap do
  begin
    create;
    fileName:=ImageList.lines[ImageIdx];
    if width>height then
      ImageWidth:=VSize
    else
      ImageWidth:=VSize/height*width;
    ImageHeight:=ImageWidth/width*height;
    x:=xCenter;
    y:=yCenter;
    dx:=ImageWidth;
    dy:=ImageHeight;
  end;

  
  {// create stim (TOnOff object)and assign the bitmap to it
  with stim do
  begin
    create;
    StartTime:=StimDelay/1000; // secondes
    DtON:= VisualStimDuration/1000;
    if NStimPerEp>1 then
    begin
      CycleCount:=NStimPerEp;
      DtOff:=(TrialInterval-VisualStimDuration)/1000; // the initial check made sure that this is >=0
    end
    else
      DtOff:= 0;
    setSyncPulse(0);
    setVisualObject(bitmap);
  end;}
  
  // create bstream to show images (and change them if necessary)
  with bstream do
  begin
    create;
    AddImage(ImageList.lines[ImageIdx]);
    // additional images: this is tricky, need to read TRecord in advance
    for i:=2 to NStimPerEp do 
    begin
      j:=TRecord.JValue[cnt+(i-1)];
      k:=StimTable[j].ImageIdx;
      AddImage(ImageList.lines[k]);
    end;
    StartTime:=StimDelay/1000;
    if Vspeed=0 then
    begin
     DtOn:=VisualStimDuration/1000;
     DtOff:=0;
    end
    else
    begin
     CycleCount:=Floor(VisualStimDuration/1000*Vspeed);
    //need to repeat the image CycleCount-1 times   
    for i:=2 to CycleCount-1 do 
    begin
        AddImage(ImageList.lines[ImageIdx]);
    end;   
     DtOn:=1/60;     //make the shortest possible light pulse (60 Hz is max framerate)
     DtOff:=(1/Vspeed - DtOn);     //the rest of the cycle is off   
    end;
    setSyncPulse(0);
    if NStimPerEp>1 then
    begin
      DtOff:=(TrialInterval-VisualStimDuration)/1000;
      CycleCount:=NStimPerEp;
    end;
    setVisualObject(bitmap);
   end; 
  end;

{procedure ChangeImage;
begin
  with bitmap do
  begin
    fileName:=ImageList.lines[ImageIdx];
    if width>height then
      ImageWidth:=VSize
    else
      ImageWidth:=VSize/height*width;
    ImageHeight:=ImageWidth/width*height;
  end;
end;}

// Luminance circle
procedure MakeLuminanceCircle;
var
  Vfreq:real;
begin
  // create circle (Tdisk object)
  with circle do
  begin
    create;
    x:=Vx;
    y:=Vy;
    dx:=VSize;
    dy:=VSize;
    Lum:= VLum;
  end;

  // create stim (TOnOff object)and assign the bar to it
  with stim do
  begin
    create;
    StartTime:=StimDelay/1000; // secondes
    Vfreq:=Vspeed;
    if Vfreq=0 then
    begin
      DtON:= VisualStimDuration/1000;
      DtOff:= 0;
    end
    else
    begin
      DtON:=1/60;           // make the shortest possible light pulse (60Hz is max frequency right now)
      DtOff:=(1/Vfreq-DtON);     // the rest of the cycle is off
      CycleCount:=Floor(VisualStimDuration/1000*Vfreq);
    end;
    setSyncPulse(0);
    setVisualObject(circle);
  end;
end;

// Looming circle
procedure MakeLoomingCircle;
var
  nframe: integer;
  cSize, cOn: TVector;
begin
  // create circle (Tdisk object)
  with circle do
  begin
    create;
    x:=xCenter;
    y:=yCenter;
    dx:=VSize;
    dy:=VSize;
    Lum:= VLum;
  end;

  // create anim (Ttrajectory object) to animate the circle 
  nframe:=Round(VisualStimDuration/1000/VisualStim.TFrame);
  vect.create(t_double,1,nframe);
  for i:=1 to nframe do 
    vect[i] := VSize + (i-1)/(nframe-1)*(VSize2-VSize);
    //vect[i] := Exp(Ln(VSize) + (i-1)/(nframe-1)*Ln(VSize2/VSize));
  cOn.create(t_smallint,1,nframe);
  for i:=1 to nframe do cOn[i]:=1;
  with anim do
  begin
    create;
    StartTime:=StimDelay/1000; // secondes
    DtON:= VisualStimDuration/1000;
    //DtOff:= 0;
    setVisualObject(circle);
    AddVector('ONSCREEN',cOn);
    AddVector('DX',vect);
    AddVector('DY',vect);
    setSyncPulse(0);
  end;
end;

// Shifting gratings
procedure initGratings(nGrating:integer);
begin
  for i:=1 to nGrating do
  begin
    // create the grating (TLgrating object)
    with gratings[i] do
    begin
      create;
      onScreen:=KeepGratingOn;
    end;
  end;
end;

procedure MakeShiftingGratings(nGrating: integer);
begin
  // create the gratings if needed (TLgrating object)
  if (not KeepGratingOn) then initGratings(nGrating); 

  for i:=1 to nGrating do
  begin
    // update the gratings
    with gratings[i] do
    begin
      dx:=stimScreen.width;
      dy:=stimScreen.height;
      Lum:=VLum;
      period:=VSize;
      phase := 0;
      SquareWave:=SquareWaveGrating;
      if nGrating=2 then
      begin
        if i=1 then blendAlpha:=1 {(1-VAlpha)} else blendAlpha:=VAlpha;
      end;
      if i=1 then orientation:=VOri else orientation:=VOri2;
    end;

   // create the shifting grating (TphaseTranslation object) and assign the grating to it
    with shiftgrat[i] do
    begin
      create;
      StartTime:=StimDelay/1000; // secondes
      DtON:= VisualStimDuration/1000;
      DtOff:= 0;
      speed:=VSpeed;
      setSyncPulse(0);
      setVisualObject(gratings[i]);
    end;
  end;
end;

// ZP for DLP photostimulation (squares)
procedure MakeOneofTwoRectangles;
begin
  // create the bar (Tbar object) 
  with bar do
  begin
    create;
    dx:=VSize;
    dy:=VSize;
    x:=Vx;
    y:=Vy;
    Lum:=VLum;
  end; 
  
  // create stim (TOnOff object)and assign the bar to it
  with stim do
  begin
    create;
    StartTime:=StimDelay/1000; // secondes
    DtON:= VisualStimDuration/1000;
    DtOff:= 0;
    setSyncPulse(0); 
    setVisualObject(bar);
  end; 
end;

procedure LoadImages;
var
  valid:boolean;
  fid:integer;
  VDirName:string;
begin
    valid := FileExists(ImageListFile);
    if valid then
    begin
      display('loading images');
      SplitFileName(ImageListFile,VDirName,str1,str2);
      fid:=1;
      OpenText(fid,ImageListFile,TRUE);
      with ImageList do
      begin
        create();
        ReadlnText(fid,str);
        while length(str)>0 do
        begin
          str:=VDirName+'\'+str;
          valid:=FileExists(str);
          if valid then
          begin
            addLine(str);
            ReadlnText(fid,str);
          end
          else
            str:='';
        end;
      end;
    end;
    if not valid then
    begin
      ImageListFile:='';
      MessageBox('Invalid image list file, or images not present');
    end;
end;

procedure ChooseImages;
begin
  ImageListFile:='*.txt';
  ChooseFile(ImageListFile,'Choose the image listing file');
  LoadImages;
  if ImageListFile<>'' then NStim:=ImageList.count;
  ParamWin.Update;
  MenuPar2FullPar;
end;

procedure emptyVisualStim;
begin
  stim.free;
  shiftgrat[1].free;
  shiftgrat[2].free;
  anim.free;
end;

// Build and assign the visual stimulation
procedure setVisualStim;
begin
  emptyVisualStim;
  // Create protocol-specific visual object and assign it to the stim
  case VStimType of
    1: MakeStarContour;  // Design the star|square shape
    2: MakeShiftingGratings(1);
    3: MakeShiftingGratings(2);
    4: MakeBitmap;
    5: MakeLuminanceCircle;
    6: MakeLoomingCircle;    // 7: corresponds to 'none'
    8: MakeOneofTwoRectangles;    //actually squares
  end;
  
// set current level of DLP LEDs:
 
//lcr.SetLedCurrents(255,255,0);          // this is max Blue LED, no current to Green and Red
lcr.SetLedCurrents(255,255,255-VLED);  // for blue LED 
  
end;

procedure initVisual;
var
  nmem: integer;
begin
  // Background luminance
  StimScreen.BackGroundLum:=BackgroundLuminance;
  
  // no light from DLP at initialization:
  lcr.create;
  lcr.SetLedCurrents(255,255,255); 
  
  
  // Mask (or set center coordinates to zero)
  // If no mask, just set the center to center of screen
  if MaskType>1 then
    MakeMask
  else
  begin
    xCenter:=0;
    yCenter:=0;
  end;

  // Init some objects
  case VStimType of
    2: if KeepGratingOn then initGratings(1);
    3: if KeepGratingOn then initGratings(2);
    4: begin
         nmem:=NStim;
         LoadImages;
         if NStim<>nmem then
           MessageBox('Number of stimuli not in accordance with number of images');
       end;
  end;
end;

procedure Initialize_AcqAndTriggs;forward;
procedure initSounds;forward;
procedure setAudioStim(immediateStart:boolean);forward;

// Test visual stimulation
procedure TestVisualStim(doAudio:boolean);
var
  i:integer;
  tmp1,tmp2:integer;
begin
  tmp1:=StimDelay;
  tmp2:=NStimPerEp;
  StimDelay:=1000;
  NStimPerEp:=1;
  
  if DoMenu then SaveDefaultMenuParameters; 
  Initialize_AcqAndTriggs;
  if Visual then initVisual;
  if Auditory and doAudio then initSounds;
  VisualStim.OnStartAnimate1:=NIL;
  VisualStim.OnStartAnimate2:=NIL;

  for i:= 1 to NStim do 
  begin
    display(Istr(i));
    ICond:=i;
    Record2Par(StimTable[i]); // update parameters for condition i
    setVisualStim;            // set stim
    if doAudio then setAudioStim(FALSE);  
    VisualStim.animate;       // play stim
    if Visualstim.StopStim then break;
  end;
  VisualStim.StopStim:=FALSE;
  
  StimDelay:=tmp1;
  NStimPerEp:=tmp2;
end;

// zp 07052014 - draws 3 crosses on the screen
procedure CalibDLPImage;
var
  //x1,y1,s1,x2,y2,s2,x3,y3,s3,k,tmp:integer; 
  x1,y1,s1,x2,y2,s2,x3,y3,s3,k,tmp,tmp2:integer; 
  const
  eps=0.05;


begin

  if DoMenu then SaveDefaultMenuParameters; 
  Initialize_AcqAndTriggs;
  initVisual;
  VisualStim.OnStartAnimate1:=NIL;
  VisualStim.OnStartAnimate2:=NIL;
  
  
  
  lcr.SetLedCurrents(255,255,55);

  //////////  
s1:=4; s2:=8; s3:=12; //size of crosses
x1:=0; y1:=0; // position of first (smallest) cross
x2:=-10; y2:=10; //position of second cross
x3:=10; y3:=10; //position of third (biggest) cross

  emptyVisualStim;

  
  // create the contour (TXYplot object) 
  with plot do
  begin
    create;   
      
       AddPolyline;
      with polylines[1] do 
      begin
        //for k:=0 to s1 do
         // addPoint(x1,y1-s1/2+k); 
              addPoint(x1-eps,y1-s1/2); 
        addPoint(x1-eps,y1+s1/2);
        addPoint(x1+eps,y1+s1/2);
        addPoint(x1+eps,y1-s1/2);
        addPoint(x1-eps,y1-s1/2);    

      
      
      end;  
    
      AddPolyline; 
      with polylines[2] do  
      begin
        //for k:=0 to s1 do
         // addPoint(x1-s1/2+k,y1);
              addPoint(x1-s1/2,y1-eps); 
        addPoint(x1+s1/2,y1-eps);
        addPoint(x1+s1/2,y1+eps);
        addPoint(x1-s1/2,y1+eps);
        addPoint(x1+s1/2,y1-eps);
   
      end;  
      
       AddPolyline;  
      with polylines[3] do 
      begin
       // for k:=0 to s2 do
         // addPoint(x2,y2-s2/2+k);
         
        addPoint(x2-eps,y2-s2/2); 
        addPoint(x2-eps,y2+s2/2);
        addPoint(x2+eps,y2+s2/2);
        addPoint(x2+eps,y2-s2/2);
        addPoint(x2-eps,y2-s2/2);  

         
      end; 
      
      AddPolyline;  
      with polylines[4] do 
      begin
        //for k:=0 to s2 do
         // addPoint(x2-s2/2+k,y2);
         
        addPoint(x2-s2/2,y2-eps); 
        addPoint(x2+s2/2,y2-eps);
        addPoint(x2+s2/2,y2+eps);
        addPoint(x2-s2/2,y2+eps);
        addPoint(x2+s2/2,y2-eps);

         
      end;  
      
             AddPolyline;  
      with polylines[5] do 
      begin
        //for k:=0 to s3 do
         // addPoint(x3,y3-s3/2+k);
         
        addPoint(x3-eps,y3-s3/2); 
        addPoint(x3-eps,y3+s3/2);
        addPoint(x3+eps,y3+s3/2);
        addPoint(x3+eps,y3-s3/2);
        addPoint(x3-eps,y3-s3/2);

         
         
      end; 
      
      AddPolyline;  
      with polylines[6] do 
      begin
        //for k:=0 to s3 do
          //addPoint(x3-s3/2+k,y3);
        addPoint(x3-s3/2,y3-eps); 
        addPoint(x3+s3/2,y3-eps);
        addPoint(x3+s3/2,y3+eps);
        addPoint(x3-s3/2,y3+eps);
        addPoint(x3+s3/2,y3-eps);

      end;
    
  end;    
  
    status.text[1]:='plot done';

  
  // create the bar (Tbar object) and assign the contour to it
  with bar do
  begin
    create;
    dx:=30;
    dy:=30;
    Lum:=VLum;
    setContour(plot);
    UseContour:=true;
  end;   
    
  // create stim (TOnOff object)and assign the bar to it
  //tmp:=StimDelay;
  //StimDelay:=300;
  
    tmp:=StimDelay;
  tmp2:=NStimPerEp;
  StimDelay:=300;
  NStimPerEp:=1;

  
  with stim do
  begin
    create;
    StartTime:=StimDelay/1000; // secondes
    DtON:= VisualStimDuration/100; // makes this 10x longer than the value in ms set for visual stim duration
    DtOff:= 0;
    setSyncPulse(0); 
    setVisualObject(bar);
  end;  
  
  
        status.text[2]:='stim created';
    lcr.SetLedCurrents(255,255,200);

     //////////////
//  StimDelay:=tmp;
         status.text[3]:='LED current set';


  VisualStim.animate;
  if Visualstim.StopStim then break;
  
    VisualStim.StopStim:=FALSE;
    status.text[4]:='VisualStim animated';
   StimDelay:=tmp;
  NStimPerEp:=tmp2;



end;

procedure LEDsOff;

begin
  lcr.SetLedCurrents(255,255,255); 
end;

{$EDIT AudioStim}
////////////////////////////////////////////////////////////////////////////////
////////////////////////// Auditory stimulation ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Load sounds
procedure LoadSounds;
var
  valid:boolean;
  fid:integer;
  SDirName:string;
begin
  valid := FileExists(SoundListFile);
  if valid then
  begin
    SplitFileName(SoundListFile,SDirName,str1,str2);
    fid:=1;
    OpenText(fid,SoundListFile,TRUE);
    with SoundList do
    begin
      create();
      ReadlnText(fid,str);
      i:=0;
      while length(str)>0 do
      begin
        i:=i+1;
        str:=SDirName+'\'+str;
        valid:=FileExists(str);
        if valid then
        begin
          display('load sound '+Istr(i)+' from '+str);
          addLine(str);
          LoadedSounds[i].create(t_single,1,1);
          LoadedSounds[i].LoadFromWaveFile(str, 1);
          LoadedSounds[i].dy:=5000/32768; // adjust to a max of 5000
          ReadlnText(fid,str);
        end
        else
          str:='';
      end;
    end;
  end;
  if not valid then
  begin
    SoundListFile:='';
    MessageBox('Invalid sound list file, or invalid sound file(s)');
  end;
end;

procedure ChooseSounds;
begin
  SoundListFile:='*.txt';
  ChooseFile(SoundListFile,'Choose the sounds listing file');
  LoadSounds;  
  if SoundListFile<>'' then NStim:=SoundList.count;
  ParamWin.Update;
  MenuPar2FullPar;
end;

procedure initSounds;
var
  fstart,fend,frac,time:real;
  SLevel,SLevel2:real;
  nS:integer;
begin
  display('Initializing sounds');

  // load sounds
  if (SoundListFile<>'') then LoadSounds;

  // load equalization parameters
  if FALSE then
  begin
    kernel.create;
    kernel.loadObject('D:\Elphy Programs\ImpulseResponse.param');
    level.create;
  end;

  // compute sounds (or copy loaded sounds) and memorize max sound duration
  MaxSoundDuration:=0;
  for i:=1 to NStim do
  begin
    // update parameters for condition i
    Record2Par(StimTable[i]); 
    // compute the sound
    case SStimType of
      1..2: // 1 or 2 tone(s)
      begin
        // create sound
        SLevel := 5000*Exp(ln(10)*((SLevelDB-100)/20));  // sine wave of amplitude 5000 corresponds to 100dB
        nS := Floor((SDuration/1000)*Sound_Sampling_Frequency);
        Sounds[i].create(T_double,0,nS-1);
        // fill it
        if (SStimType=1) then SAlpha:=0; // only one sound <-> second sound is zero
        for k:=Sounds[i].Istart to Sounds[i].Iend do
        begin
          time := k / Sound_Sampling_Frequency;
          Sounds[i][k] := SLevel*(1-SAlpha)*Sin(2*PI*SFreq*time);
          if (SAlpha>0) then Sounds[i][k] := Sounds[i][k] + SLevel*SAlpha*Sin(2*PI*SFreq2); 
        end;
      end;
      3..4: // 1 or 2 frequency ramp(s)
      begin
        // create sound
        SLevel := 5000*Exp(ln(10)*((SLevelDB-100)/20));
        nS := Floor((SDuration/1000)*Sound_Sampling_Frequency);
        Sounds[i].create(T_double,0,nS-1);         
        if (SStimType=3) then SAlpha:=0; // only one sound <-> second sound is zero
        // Frequency ramp generation:
        // instantaneous frequency at time t = f1 + t/T*(f2-f1);
        // phase at time t = 2Pi * integral_0-t frequency(t)*t
        //                 = 2Pi*f1*t + Pi*t^2/T*(f2-f1)
        // with t = i/Sound_Sampling_Frequency
        frac := (SFreq2-SFreq)/(nS/Sound_Sampling_Frequency);
        for k:=Sounds[i].Istart to Sounds[i].Iend do
        begin
          time := k / Sound_Sampling_Frequency;
          Sounds[i][k] := SLevel*(1-SAlpha)*Sin(2*PI*SFreq*time + PI*time*time*frac);
          if (SAlpha>0) then Sounds[i][k] := Sounds[i][k] + SLevel*SAlpha*Sin(2*PI*SFreq2*time - PI*time*time*frac); 
        end;
      end;
      5: // loaded files
      begin
        Sounds[i].create;
        VCopy(LoadedSounds[SoundIdx],Sounds[i]);
        SDuration := Sounds[i].icount/Sound_Sampling_Frequency*1000;
      end;
      6: // two loaded files and amplitude morphing
      begin
        if LoadedSounds[1].icount<>LoadedSounds[2].icount then
          ErrorDlg('Loaded sounds are not of the same length');
        Sounds[i].create(T_double,LoadedSounds[1].istart,LoadedSounds[2].iend);
        for k:=LoadedSounds[1].istart to LoadedSounds[1].iend do
          Sounds[i][k] := LoadedSounds[1][k]*(1-SAlpha) + LoadedSounds[2][k]*SAlpha; 
        SDuration := LoadedSounds[1].icount/Sound_Sampling_Frequency*1000;
      end;
      7: // amplitude ramp
      begin
        // create sound
        nS := Floor((SDuration/1000)*Sound_Sampling_Frequency);
        Sounds[i].create(T_double,0,nS-1);
        // fill it
        frac:=(SLevelDB2-SLevelDB)/(SDuration/1000); 
        for k:=Sounds[i].Istart to Sounds[i].Iend do
        begin
          time := k / Sound_Sampling_Frequency;
          SLevel := 5000*Exp(ln(10)*((SLevelDB+frac*time-100)/20));
          if SFreq>0 then
            // 100 dB <-> sine wave of amplitude 5000
            Sounds[i][k] := SLevel*Sin(2*PI*SFreq*time)
          else
            // 100dB <-> signal of std 5000/sqrt(2)
            Sounds[i][k] := (SLevel/sqrt(2))*RandomN;
        end;
      end;
      8: // none 
      begin
        // vector filled with zeros
        nS := Floor((SDuration/1000)*Sound_Sampling_Frequency);
        Sounds[i].create(T_double,0,nS-1);
        for k:=0 to nS-1 do Sounds[i][k]:=0;
      end;
    end;

    // update max sound duration
    MaxSoundDuration:=max(MaxSoundDuration,SDuration);
    
    // equalization
    if FALSE then
    begin
      vect.create;
      VCopy(Sounds[i],vect);
      kernel.dx := Sounds[i].dx;
      Convolve(vect,kernel,Sounds[i]);
      VMulNum(Sounds[i],Exp((5-level.dB0/20)*Ln(10)));
    end;

    // make sure the vector finishes with a zero
    Sounds[i][Sounds[i].Iend]:=0;

  end;

  display('');
end;


// Deliver the sound stimulus
procedure setAudioStim(immediateStart:boolean);
begin
  with NIanalog do
  begin
    create(Dev);
    setAnalogOutput(0,1000/Sound_Sampling_Frequency,SDuration,FALSE);
    VCopy(Sounds[ICond],vector);
    if immediateStart then
      start('')
    else
      start(PFI); // set trigger
  end;
end;

// Test sounds
procedure TestSounds;
begin                        
  if DoMenu then SaveDefaultMenuParameters; 
  Initialize_AcqAndTriggs;
  initSounds;

  status.text[3]:=('Test Sounds');

  for i:= 1 to  NStim  do  
  begin
    if i>1 then delay(round(SDuration+300) );  
    display(Istr(i));
    if ProtocolType=2 then 
      // untwist twisted sounds for "Double unimodal ambiguities" protocol!!! 
      if i<=NStim/2 then ICond:=Floor(NStim/2)+1-i else ICond:=NStim+1-(i-Floor(NStim/2)) 
    else
      ICond:=i; 
    Record2Par(StimTable[ICond]);
    setAudioStim(TRUE);
    if Visualstim.StopStim then break;
  end;
  VisualStim.StopStim:=FALSE;
end;

{$EDIT Reward}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////// Reward routines /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Opens transiently the water valve
procedure OpenValve(volume: real);
begin
  with NIanalog do
  begin
    create(Dev);
    setAnalogOutput(1,1,volume*rewardConversion,false);
    vector.fill(5000);
    vector[vector.Iend]:=0;
    start('');
    rewardTotal:=rewardTotal+volume;
    ParamWin.update;
    delay(Floor(volume*rewardConversion)+100);
  end;

end;

// Opens or close the water valve
procedure OpenCloseValve;
begin
  with NIanalog do
  begin
    create(Dev);
    setAnalogOutput(1,1,10,false);
    vector.fill(5000*Ord(ValveOpen));
    start('');
    delay(100);
  end;

end;


// Procedure to check if reward will be given and call the OpenValve procedure if necessary
procedure RewardFunction;
var
  det: Tdetect; // We use a Tdetect object for the lick detection
  w,w1,w2: integer;
begin
  Case DetectionType of
    // Head-fixed touch
    1:
    begin
     with det do
      begin
       create;
       installSource(v1);
       Xstart:=StimDelay+LickCountingDelay;
       Xend:=StimDelay+VisualStimDuration+RewardDelay;
       mode:= sm_crossDw;
       Length:= 50;
       height:= LickThresholdTop;
       execute;
     end;
     w1:= det.count;

     with det do
      begin
       height:= LickThresholdBottom;
       execute;
      end;
     w2:= det.count;
     if (w1<=w2) then w:=w1 else w:=w2;
    end;
    
    // Head-fixed licking
    2:
    begin
    v1.CpX:=1;
    v1.CpY:=1;
    vfilt.CpX:=v1.CpX;
    vfilt.CpY:=v1.CpY;
    Filter(1,FALSE,2,10,v1,vfilt,v1.Xstart,v1.Xend);
    vfilt.refresh;
    with det do
      begin
       create;
       installSource(vfilt);
       Xstart:=StimDelay+LickCountingDelay;
       Xend:=StimDelay+VisualStimDuration+RewardDelay;
       mode:= sm_min;
       height:= -LickThresholdBottom;
       execute;
      end;
      w:= det.count;
      Vbase:=vfilt.Maxi0;
     end;

    // Freely moving
    3:
     begin
      vfilt.create;
      vcopy1(v1,vfilt);
      vfilt.Threshold1(LickThresholdTop);
      w:=100-floor(100*vfilt.Mean(StimDelay+VisualStimDuration,StimDelay+VisualStimDuration+RewardDelay));
     end;
     
         // Head-fixed licking with active electric contact
    4:
    begin
    v1.CpX:=1;
    v1.CpY:=1;
    vfilt.CpX:=v1.CpX;
    vfilt.CpY:=v1.CpY;
    Filter(1,FALSE,2,10,v1,vfilt,v1.Xstart,v1.Xend);
    vfilt.refresh;
    with det do
      begin
       create;
       installSource(vfilt);
       Xstart:=StimDelay+LickCountingDelay;
       Xend:=StimDelay+VisualStimDuration+RewardDelay;
       mode:= sm_max;
       height:= LickThresholdTop;
       execute;
      end;
      w:= det.count;
      Vbase:=vfilt.Mini0;
     end;

     
  end;

  // Give the reward if correct answer to S+ (or free S+ trial)
  if (TaskType=1) AND activeReward AND ((w>= LickNumber) OR (cnt<=NFreeTrials)) then 
    OpenValve(Floor(rewardVolume+max(0,w-LickNumber)*rewardSlope));
     
  // Record the number of licks
  status.text[5]:=Istr(w)+' lick(s)';
  LickRecord[cnt]:=w;
  
  // Record whether the trial was correct
  case TaskType of
    1: CRecord[cnt] := Ord(w>=LickNumber);
    2: CRecord[cnt] := Ord(w< LickNumber);
  end;
end;

{$EDIT Acquisition}
////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Detector routines ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// CASE 1 : TRIGGER AN IMMEDIATE REWARD


procedure ImmediateRewardFunction(n:integer);



begin
  if ContinuousRec then
    // continuous run with immediate rewards
    OpenValve(rewardVolume)
  else
  
    // count licks into CountLicks:
    if (TaskType=1) AND (Vdetect[Vdetect.Iend]>StimDelay+LickCountingDelay) AND (activeReward) AND (CountLicks<LickNumber) then
    begin
    CountLicks:=CountLicks+1;
    end;
     
    // reward if S+ and correct response
    if (TaskType=1) AND (Vdetect[Vdetect.Iend]>StimDelay+LickCountingDelay) AND (activeReward) AND (CountLicks=LickNumber) then
    begin
      OpenValve(rewardVolume);
      activeReward:=FALSE;
      CountLicks:=0; //reset lick counter
    end;
end;

procedure InitDetectorReward;
begin
  Vdetect.create;
  activeReward:=TRUE;
  CountLicks:=0;
  with detector do
  begin
    create;
    // detector events are initiated by threshold crossing:
    // arguments 3 and 4 tell whether up-crossings and down-crossings generate an event
    status.text[4]:='Vbase='+Rstr(Vbase,5,2);
    initCrossings(v1,Vdetect, true,false, LickThresholdTop+Vbase,LickThresholdBottom+Vbase, 100, Vbase,false);

    AddEvent(ImmediateRewardFunction,0);
  end;
end;

// CASE 2 : RYTHMICALLY UPDATE THE IMAGE/SOUND TO BE PLAYED

procedure SelectTrialType;forward;

procedure DetectorEventStimUpdate(n:integer);
begin
  if n<NStimPerEp then
  begin
    SelectTrialType;
    if Auditory then setAudioStim(FALSE);
  end;
end;

procedure InitDetectorStimUpdate;
var
  StimDuration: real;
begin
  with detector do
  begin
    create;
    // detector events are initiated by a timer
    if Auditory then
      if Visual then 
        StimDuration:=max(MaxSoundDuration,VisualStimDuration+RewardDelay) 
      else 
        StimDuration:=MaxSoundDuration
    else
      StimDuration:=VisualStimDuration+RewardDelay;
    initTimer(v1,TrialInterval,StimDelay+StimDuration+50);
    AddEvent(DetectorEventStimUpdate,0);
  end;
end;

// THE LINES BELOW ARE NECESSARY FOR THE DETECTOR TO ACT WHEN IN CONTINUOUS ACQUISITION MODE

ProcessCont
detector.update(v1.Iend);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Trigger routines /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Wait for triggers
procedure WaitForFork;
var
  LickV,thresh,del:real;
  NREF,NC:integer;
  ref:boolean;
  Address:string;
begin
  display('wait for fork');
  Address:=Dev+'/AI1';
  thresh:=2;
  del:=20;
  NC:=0;
  ref:=FALSE;
  NREF:=floor((RefractoryTime+Random*RandomRefractoryTime)/del);
  repeat
    Ni.Ain(Address,1,LickV);
    if LickV>=thresh then NC:=NC+1;
    if NC>=NREF then ref:=TRUE;
    if LickV<thresh then NC:=0;
    delay(floor(del));

  until ((LickV<thresh) AND (ref)) OR Visualstim.StopStim;
  display('Trial');
end;

procedure WaitForNoLick;
var
  LickV,LickThresholdUser,thresh,del,RefreshTime:real;
  NREF,NREFRE,NC,NC0:integer;
  ref:boolean;
  Address:string;
begin

  display('wait for no lick');
  Address:=Dev+'/AI0'; 
    if DetectionType=2 then 
    LickThresholdUser:=LickThresholdBottom 
  else if DetectionType=4 then
    LickThresholdUser:=LickThresholdTop
  else
    ErrorDlg('Wrong detection type encountered in WaitForNoLick');
  thresh:=(Vbase+LickThresholdUser)/1000;
  status.text[4]:='Vbase=' + Rstr(Vbase,5,2); 
  del:=10;
  NC:=0;  NC0:=0;
  ref:=FALSE;
  NREF:=floor((RefractoryTime+Random*RandomRefractoryTime)/del);
  NREFRE:=floor(1000/del);
  WaitVect.create(5,1,NREFRE);
  repeat
      delay(floor(del));
    display('wait for no lick: '+Rstr((NREF-NC)*del,5,2));

    Ni.Ain(Address,1,LickV);
    NC0:=NC0+1; WaitVect[NC0]:=LickV;
    
    if ((DetectionType=2) AND (LickV>=thresh)) OR ((DetectionType=4) AND (LickV<=thresh)) then
      NC:=NC+1
    else
      NC:=0;

    if NC>=NREF then ref:=TRUE;

    if NC0>=NREFRE then
      begin
          if DetectionType=2 then Vbase:=WaitVect.Maxi0*1000 else Vbase:=WaitVect.Mini0*1000;
          thresh:=(Vbase+LickThresholdUser)/1000;
          NC0:=0;
      end;

  
       // status.text[3]:='B'+Rstr(Vbase,5,2)+'T'+Rstr(thresh,5,2)+'NC'+Istr(NC)+'NC0'+Istr(NC0);

   // status.text[3]:=Istr(NC);
   // status.text[4]:=Rstr(LickV,5,2);
   // status.text[6]:=Rstr(thresh,5,2);
    until ref OR Visualstim.StopStim;
  display('Trial');
end;

procedure WaitForMicroscope;
var
  dig,ok:integer;
  Address:string;
begin
  display('wait for microscope');
  Address:=Dev+'/PORT1/LINE2';
  // first get a 0 bit (make sure previous acquisition has finished)
  repeat
    ok:=Ni.Din(Address,dig);
    visualStim.TestStopStim;
  until (dig=0) OR Visualstim.StopStim;
  // then get a 1 bit (trigger)
  repeat
    ok:=Ni.Din(Address,dig);
    visualStim.TestStopStim;
  until (dig>0) OR Visualstim.StopStim;
end;

////////////////////////////////////////////////////////////////////////////////
////////////////////////// Acquisition /////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


// Procedure for Episodes recording
procedure Initialize_AcqAndTriggs;
var
  SoundStart, EpisodeDuration, soundStartMS, pulseDur: integer;
begin

  // Set general parameters of acquisition
  if (NStimPerEp>1) then
    // note: the initial checks ensure that TrialInterval >= VisualStimDuration+RewardDelay+100ms
    EpisodeDuration := StimDelay+NStimPerEp*TrialInterval
  else
    EpisodeDuration := StimDelay+VisualStimDuration+RewardDelay; // seconds
  with VisualStim do
  begin
    // EphysPeriod is the period chosen for acquiring electrophysiology data (v3). Other channels are adjusted with DownSamplingFactor such
    // that their period is 1ms.
    PeriodPerChannel:=EphysPeriod; // unit: ms
    //PeriodPerChannel:=0.01; // unit: ms
    // Erase all displays
    emptyVisualStim;
    // Handle triggers
    VisualStim.OnStartAnimate1:=NIL;
    VisualStim.OnStartAnimate2:=NIL;
    case TriggerType of
      2: VisualStim.OnStartAnimate1:=WaitForFork;
      3: VisualStim.OnStartAnimate1:=WaitForMicroscope;
      4: VisualStim.OnStartAnimate1:=WaitForNoLick;
    end;
  end;
  MakeDumBar(EpisodeDuration);
  if MaskType>1 then MakeMask else for i:=1 to 2 do maskBar[i].free;

  // Set input parameters
  with Acquisition do
  begin
    Fcontinuous:=false;
    if TRUE then
    begin
      ChannelCount:=3; //2;
      with Channels[1] do
      begin
        if Behavior then
          case DetectionType of
            1: PhysNum:=1;
            2: PhysNum:=0;
            3: PhysNum:=1;
            4: PhysNum:=0;
          end
        else
          PhysNum:=1; // nothing to record -> record audio stim, just for fun
        UnitY:='mV';
        setScale(0,32767,0,10000);
        DownSamplingFactor:= floor(1/EphysPeriod);       // so that sampling period on that channel is 1 ms.
      end;
      
      with Channels[2] do    //can be used for recording output of photodetector, to test temporal structure of visual stimuli
      begin
       PhysNum:=2; //put to 0 when not in use
       UnitY:='mV';
       setScale(0,32767,0,10000);
       DownSamplingFactor:= 1; //floor(1/EphysPeriod);   // so that sampling period on that channel is 1 ms.
      end ;
      
      with Channels[3] do    //for ephys recording
      begin
       PhysNum:=3;
       UnitY:='mV';
       setScale(0,32767,0,10000/EphysGain); // 10000 mV (the max) at the input to the NI card corresponds to 10 mV in the brain 
       //(before xEphysGain amplification by the extracellular headstage and the BVC-700A)
       DownSamplingFactor:= 1;
      end ;
    
      Fstimulate:=true;
    end
    else
    begin
      ChannelCount:=0;
    end;
  end;

  // Set output parameters
  with Stimulator do
  begin
    BufferCount:=1;
    ChannelCount:=2;
    setByProg:=true;

    // Trigger for sound
    with Channels[1] do
    begin
      ChannelType:=TO_digiBit;
      PhysNum:=0;
      BitNum:=7;
    end;
    
      with Channels[2] do
    begin
      ChannelType:=TO_digiBit;
      PhysNum:=0;
      BitNum:=6;
    end;

    // Init visual stimulation - this also sets acquisition
    // It is important that this commands occurs here, after we have declared
    // Channels[1], but before we set the content of vector[1] (since 'InitAcqParams'
    // sets the appropriate length of vector[1])
    VisualStim.InitAcqParams; 

    // Fill the output vector of the sound trigger
    vector[1].fill(0);
    for i:=1 to NStimPerEp do
    begin
      soundStartMS := StimDelay+(i-1)*TrialInterval+Round(SDelay);
    //  soundStart := floor(soundStartMS / VisualStim.PeriodPerChannel);
    //  pulseDur := floor(10 / VisualStim.PeriodPerChannel);
        soundStart := soundStartMS ;
      pulseDur :=10 ;
      vector[1].fill1(1,soundStart,soundStart+pulseDur);  // Ce pulse est envoy sur PFI1, il dclenche le signal analogique
    end;
    
    
    // Fill the output vector of the external ephys trigger
    vector[2].fill(0);
    pulseDur :=1000 ;
    vector[2].fill1(1,0,pulseDur);  // Ce pulse est envoy dans le systeme Intan


  end;

  // Set display range of acquisition
  v1.Xmin:=0;
  v1.Xmax:=EpisodeDuration;
  if Behavior then
    case DetectionType of
      1: begin v1.Ymin:=0; v1.Ymax:=5500; end;
      2: begin v1.Ymin:=-10500; v1.Ymax:=10500; end;
      3: begin v1.Ymin:=0; v1.Ymax:=5500; end;
    end
  else
    begin v1.Ymin:=-500; v1.Ymax:=500; end;
    
  v3.Xmin:=0;
  v3.Xmax:=EpisodeDuration;
  v3.Ymin:=-20/EphysGain;
  v3.Ymax:=20/EphysGain; 
  
  
  v2.Xmin:=0;
  v2.Xmax:=EpisodeDuration;
  v2.Ymin:=-1000;
  v2.Ymax:=1000;

end;


{$EDIT Experiment}
////////////////////////////////////////////////////////////////////////////////
////////////////////////// Program opening /////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// The procedure that intializes the program
procedure Opening_Procedure;
begin         
  // randomize seed for RNG
  Randomize; 
  
  // Build the page
  DesignPage;

  // Init experiment parameters and other variables
  InitSettings;

  // Initialize data vector
  with LickRecord do
  begin
   create(t_smallint,0,1);
   Ymin:=0;
   Ymax:=20;
  end;
  with CRecord do
  begin
   create(t_smallint,0,1);
   Ymin:=-1;
   Ymax:=2;
  end;
  TRecord.create(t_smallint,1,1);

  // Put vectors into graph and build menus (though menus were already built by 'InitSettings')
  FillPage;
  
  // Status bar
  with status do
  begin
    create(7);
    setPanelProp(1,400,2,1,'');
    setPanelProp(2,120,2,1,'');
    setPanelProp(3,200,2,1,'');
    setPanelProp(4,200,2,1,'');
    setPanelProp(5,120,2,1,'');
    setPanelProp(6,120,2,1,'');
  end;
  hideSystemStatusBar;

  // Set a gray screen
  StimScreen.BackGroundLum:=BackgroundLuminance;
end;

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// Episode //////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Randomization function
procedure BuildTRecord;
var
   i,j,idx,nblock,tmp:integer;
begin
  // Create vector with all conditions repeated NRepPerBlock times
  nblock := NStim*NRepPerBlock;
  RandomizationVector.create(t_longint,0,nblock-1);
  for i:=1 to NStim do
    for j:=0 to NRepPerBlock-1 do
      RandomizationVector[(i-1)*NRepPerBlock+j] := i;
  // Loop on trial number
  for cnt:=1 to MaxTrialNumber do
  begin
    idx := (cnt-1) mod nblock;
    // re-shuffle vector?
    if idx=0 then
      for i:=0 to nblock-1 do
      begin
        j := floor(nblock*Random);
        tmp := RandomizationVector.JValue[i];
        RandomizationVector[i] := RandomizationVector.JValue[j];
        RandomizationVector[j] := tmp;
      end;
    // get trial type
    TRecord[cnt]:=RandomizationVector.JValue[idx];
  end;
  cnt:=0; // reinit trial counter
end;

// Select trial type, update stim parameters
procedure SelectTrialType;
begin
  // increment stim count (starts at 1 for the first trial)
  inc(cnt);
  // get trial type
  ICond:=TRecord.JValue[cnt];
  // update stim parameters
  Record2Par(StimTable[ICond]);
  // display
  status.text[2] := 'Stim '+Istr(cnt)+' -> '+Istr(ICond);
end;

// Procedure defining what to do in each episode
procedure DoEpisode;
var
  timestart,dd:integer;
begin
  // Choose the type of trial
  SelectTrialType; // This sets ICond, increments cnt, updates TRecord, and updates stim parameters
  
  // Init the detector if necessary?
    if Behavior and ((RewardCriterion=2) OR (RewardCriterion=4)) then
  begin
    InitDetectorReward; // detector for immediate reward
    VisualStim.InstallDetector(detector);
  end
  else if (NStimPerEp>1) and Auditory then
  begin
    InitDetectorStimUpdate; // detector for multiple images/sounds per episode
    VisualStim.InstallDetector(detector);
  end
  else detector.free;
  activeReward:=TRUE;

  // Prepare the stimulation
  display('set visual stim');
  if Visual then setVisualStim;           // Refresh the visual stimulation
  display('set audio stim');
  if Auditory then setAudioStim(FALSE);      // Refresh and load the auditory stimulation

  // If NStimPerEp>1, cnt will be updated by the detector BUT the detector is 
  // installed ONLY if there is Auditory stimulation (it is best not to use 
  // detectors when possible, because they slow down the visual stimulation)
  // If there is only Visual stimulation, we need to update cnt "by hand": This 
  // line needs to be executed AFTER setVisualStim (which uses cnt)
  if (NStimPerEp>1) and (not Auditory) then cnt:=cnt+(NStimPerEp-1);

  // Start acquisition
  display('Visualstim.animate');
  timestart := timeGetTime;
  VisualStim.animate;       // Launch the visual stimulation immediately

  // Reward
  if Behavior then
  begin
    RewardFunction;         // Check the number of licks and deliver the reward
    activeReward:=TRUE;
    LickRecord.refresh;
    CRecord.refresh;
  end;

  // Add a delay before the next episode
  dd := TrialInterval;               // Minimal duration of trial
  dd := (timestart+dd)-timeGetTime;  // Remaining time to wait
  if dd>0 then
  begin
    display('wait for some delay');
    delay(dd);
  end;
  if Behavior AND (TaskType=2) AND (CRecord[cnt]=0) AND (PunitionDelay>0) then
  begin
    display('punition delay');    // punishment for false positive
    delay(PunitionDelay);
    dd := dd+PunitionDelay;
  end;
  if RandomDelay>0 then
  begin
    display('random delay');
    delay(Floor(Random*RandomDelay));
  end;
  display('');
  
end;

////////////////////////////////////////////////////////////////////////////////
////////////////////////// Experiment routines /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


procedure RunEpisodes;
var
i:integer;
MatName:string;
tmp:real;
Address:string;


begin
if VisualStim.OpenDataFile then
  begin

    // Initialize acquisition and triggers
    Initialize_AcqAndTriggs;

    // Set storage vectors (and precompute all condition numbers)
    TRecord.modify(2,1,MaxTrialNumber);     TRecord.Xmax:=MaxTrialNumber;
    BuildTRecord;
    CRecord.modify(2,1,MaxTrialNumber);     CRecord.Xmax:=MaxTrialNumber;
    LickRecord.modify(2,1,MaxTrialNumber);  LickRecord.Xmax:=MaxTrialNumber;

    // Initialize trial counter
    cnt:=0; // cnt is incremented at each call to SelectTrialType
    
    // Pre-compute sounds
    if Visual then initVisual;
    if Auditory then initSounds;

    // Estimate baseline voltage
    if Behavior then
      begin
       Address:=Dev+'/AI0';
       Ni.Ain(Address,1,tmp);
       Vbase:=tmp*1000;
       delay(50);
       Ni.Ain(Address,1,tmp);
      if (tmp*1000>Vbase) AND (DetectionType=2) then Vbase:=tmp*1000;
       status.text[4]:='Vbase=' + Rstr(Vbase,5,2);

    end;

    // Episodes loop
    repeat
      DoEpisode;                        // Launch episode
    until (cnt=MaxTrialNumber) or Visualstim.StopStim;  // Note that cnt is incremented in SelectTrialType function
    VisualStim.StopStim:=FALSE;

    // Save parameters and computed vectors
    SaveParametersDatafile;
    DataFile0.AppendObject(TRecord);
    DataFile0.AppendObject(CRecord);
    DataFile0.AppendObject(LickRecord);
  end;
end;


// Procedures for continuous recording
var
  MatName: string;

EndProcess
if DetectionType=1 then
begin
   detector.update(v1.Iend); // this also applies for episodes recording
end;
if ContinuousRec then
begin
  // save in Elphy data file
  SaveParametersDatafile;                         // Marche pas!
  DataFile0.AppendObject(Vdetect);     // Marche pas!
  // save for Matlab
  MatName:= DataPath+DataName+'.mat';
  if Vdetect.icount>0 then Vdetect.SaveToMatFile(MatName,'PedalTimes', 7 , FALSE);
end;

procedure RunContinuous;
begin
  // ACQUISITION
  // init acquisition
  with Acquisition do
  begin
    Fcontinuous:=true;
    Fdisplay:=true;
    FimmediateDisplay:=true;
    ChannelCount:=1;
    with Channels[1] do
    begin
      PhysNum:=0;
      UnitY:='mV';
      setScale(0,32767,0,10000);
      DownSamplingFactor:= 1;
    end;
    Fstimulate:=false;
  end;
  // init event detection
  InitDetectorReward;
  // display parameters
  v1.Xmin:=0;
  v1.Xmax:=10;
  // start acquisition
  acquisition.startAndSave;

  // SAVE
  // done in 'EndProcess' above
end;

// General experiment procedure
procedure RunTheExp;
begin
  // Check current settings
  if not CheckCurrentSettings then break;
  // Save menu parameters to default
  if DoMenu then SaveDefaultMenuParameters;
  // Re-init some variables
  InitRewardCount;
  // Erase status information
  for i:=1 to 7 do status.text[i]:='';
  // Call the procedure for Episodes or Continuous recording
  if ContinuousRec then RunContinuous else RunEpisodes;
  // Update the generic file name
  Acquisition.GenericFileName := DataPath+DataName+'.DAT';
end;



////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Program ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

program 'Open program'
Opening_procedure;
